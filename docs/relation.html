<!DOCTYPE html>

<html>
<head>
  <title>relation.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="bookshelf.html">
                bookshelf.js
              </a>
            
              
              <a class="source" href="collection.html">
                collection.js
              </a>
            
              
              <a class="source" href="collectionbase.html">
                collectionbase.js
              </a>
            
              
              <a class="source" href="eager.html">
                eager.js
              </a>
            
              
              <a class="source" href="events.html">
                events.js
              </a>
            
              
              <a class="source" href="helpers.html">
                helpers.js
              </a>
            
              
              <a class="source" href="model.html">
                model.js
              </a>
            
              
              <a class="source" href="modelbase.html">
                modelbase.js
              </a>
            
              
              <a class="source" href="relation.html">
                relation.js
              </a>
            
              
              <a class="source" href="sync.html">
                sync.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>relation.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="keyword">function</span>(define) { <span class="string">"use strict"</span>;

define(<span class="keyword">function</span>(require, exports, module) {</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>All external dependencies are referenced through a local module,
so that you can modify the <code>exports</code> and say... swap out <code>underscore</code>
for <code>lodash</code> if you really wanted to.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> _          = require(<span class="string">'./ext/underscore'</span>)._;
  <span class="keyword">var</span> when       = require(<span class="string">'./ext/when'</span>).when;
  <span class="keyword">var</span> inflection = require(<span class="string">'./ext/inflection'</span>).inflection;

  <span class="keyword">var</span> Helpers        = require(<span class="string">'./helpers'</span>).Helpers;
  <span class="keyword">var</span> ModelBase      = require(<span class="string">'./modelbase'</span>).ModelBase;
  <span class="keyword">var</span> CollectionBase = require(<span class="string">'./collectionbase'</span>).CollectionBase;</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Array helpers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> array = [];
  <span class="keyword">var</span> push  = array.push;</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Used internally, the <code>Relation</code> helps in simplifying the relationship building,
centralizing all logic dealing with type &amp; option handling.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> Relation = <span class="keyword">function</span>(type, Target, options, Model, Collection) {
    <span class="keyword">this</span>.type = type;
    <span class="keyword">if</span> (<span class="keyword">this</span>.target = Target) {
      <span class="keyword">this</span>.targetTableName = _.result(Target.prototype, <span class="string">'tableName'</span>);
      <span class="keyword">this</span>.targetIdAttribute = _.result(Target.prototype, <span class="string">'idAttribute'</span>);
    }
    <span class="keyword">this</span>.Model = Model;
    <span class="keyword">this</span>.Collection = Collection;
    _.extend(<span class="keyword">this</span>, options);
  };

  Relation.prototype = {</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Assembles the new model or collection we&#39;re creating an instance of,
gathering any relevant primitives from the parent object,
without keeping any hard references.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    init: <span class="keyword">function</span>(parent) {
      <span class="keyword">this</span>.parentId = parent.id;
      <span class="keyword">this</span>.parentTableName   = _.result(parent, <span class="string">'tableName'</span>);
      <span class="keyword">this</span>.parentIdAttribute = _.result(parent, <span class="string">'idAttribute'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>If the parent object is eager loading, we don&#39;t need the
id attribute, because we&#39;ll just be creating a <code>whereIn</code> from the
previous response anyway.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (!parent._isEager) {
        <span class="keyword">if</span> (<span class="keyword">this</span>.isInverse()) {
          <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'morphTo'</span>) {
            <span class="keyword">this</span>.target = Helpers.morphCandidate(<span class="keyword">this</span>.candidates, parent.get(<span class="keyword">this</span>.key(<span class="string">'morphKey'</span>)));
          }
          <span class="keyword">this</span>.parentFk = parent.get(<span class="keyword">this</span>.key(<span class="string">'otherKey'</span>));
        } <span class="keyword">else</span> {
          <span class="keyword">this</span>.parentFk = parent.id;
        }
      }

      <span class="keyword">var</span> target = <span class="keyword">this</span>.target ? <span class="keyword">this</span>.relatedInstance() : {};
          target.relatedData = <span class="keyword">this</span>;

      <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'belongsToMany'</span>) {
        _.extend(target, pivotHelpers);
      }

      <span class="keyword">return</span> target;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Initializes a <code>through</code> relation, setting the <code>Target</code> model and <code>options</code>,
which includes any additional keys for the relation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    through: <span class="keyword">function</span>(source, Target, options) {
      <span class="keyword">var</span> type = <span class="keyword">this</span>.type;
      <span class="keyword">if</span> (type !== <span class="string">'hasOne'</span> &amp;&amp; type !== <span class="string">'hasMany'</span> &amp;&amp; type !== <span class="string">'belongsToMany'</span> &amp;&amp; type !== <span class="string">'belongsTo'</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'`through` is only chainable from `hasOne`, `belongsTo`, `hasMany`, or `belongsToMany`'</span>);
      }

      <span class="keyword">this</span>.throughTarget = Target;
      <span class="keyword">this</span>.throughTableName = _.result(Target.prototype, <span class="string">'tableName'</span>);
      <span class="keyword">this</span>.throughIdAttribute = _.result(Target.prototype, <span class="string">'idAttribute'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Set the parentFk as appropriate now.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'belongsTo'</span>) {
        <span class="keyword">this</span>.parentFk = <span class="keyword">this</span>.parentId;
      }

      _.extend(<span class="keyword">this</span>, options);
      _.extend(source, pivotHelpers);</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Set the appropriate foreign &amp; other keys if we&#39;re doing a belongsToMany,
for convenience.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'belongsToMany'</span>) {
        <span class="keyword">this</span>.foreignKey = <span class="keyword">this</span>.throughForeignKey;
      }

      <span class="keyword">return</span> source;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Generates and returns a specified key, for convenience... one of
<code>foreignKey</code>, <code>otherKey</code>, <code>throughForeignKey</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    key: <span class="keyword">function</span>(keyName) {
      <span class="keyword">if</span> (<span class="keyword">this</span>[keyName]) <span class="keyword">return</span> <span class="keyword">this</span>[keyName];
      <span class="keyword">if</span> (keyName === <span class="string">'otherKey'</span>) {
        <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'morphTo'</span>) <span class="keyword">return</span> <span class="keyword">this</span>[keyName] = <span class="keyword">this</span>.morphName + <span class="string">'_id'</span>;
        <span class="keyword">return</span> <span class="keyword">this</span>[keyName] = singularMemo(<span class="keyword">this</span>.targetTableName) + <span class="string">'_'</span> + <span class="keyword">this</span>.targetIdAttribute;
      }
      <span class="keyword">if</span> (keyName === <span class="string">'throughForeignKey'</span>) {
        <span class="keyword">return</span> <span class="keyword">this</span>[keyName] = singularMemo(<span class="keyword">this</span>.joinTable()) + <span class="string">'_'</span> + <span class="keyword">this</span>.throughIdAttribute;
      }
      <span class="keyword">if</span> (keyName === <span class="string">'foreignKey'</span>) {
        <span class="keyword">if</span> (<span class="keyword">this</span>.isMorph()) <span class="keyword">return</span> <span class="keyword">this</span>[keyName] = <span class="keyword">this</span>.morphName + <span class="string">'_id'</span>;
        <span class="keyword">return</span> <span class="keyword">this</span>[keyName] = singularMemo(<span class="keyword">this</span>.parentTableName) + <span class="string">'_'</span> + <span class="keyword">this</span>.parentIdAttribute;
      }
      <span class="keyword">if</span> (keyName === <span class="string">'morphKey'</span>) <span class="keyword">return</span> <span class="keyword">this</span>[keyName] = <span class="keyword">this</span>.morphName + <span class="string">'_type'</span>;
      <span class="keyword">if</span> (keyName === <span class="string">'morphValue'</span>) <span class="keyword">return</span> <span class="keyword">this</span>[keyName] = <span class="keyword">this</span>.parentTableName || <span class="keyword">this</span>.targetTableName;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Injects the necessary <code>select</code> constraints into a <code>knex</code> query builder.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    selectConstraints: <span class="keyword">function</span>(knex, options) {
      <span class="keyword">var</span> resp = options.parentResponse;</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>The base select column</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (knex.columns.length === <span class="number">0</span> &amp;&amp; (!options.columns || options.columns.length === <span class="number">0</span>)) {
        knex.columns.push(<span class="keyword">this</span>.isJoined() ? <span class="keyword">this</span>.targetTableName + <span class="string">'.*'</span> : <span class="string">'*'</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> (_.isArray(options.columns) &amp;&amp; options.columns.length &gt; <span class="number">0</span>) {
        push.apply(knex.columns, options.columns);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>The <code>belongsToMany</code> and <code>through</code> relations have joins &amp; pivot columns.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>.isJoined()) {
        <span class="keyword">this</span>.joinClauses(knex);
        <span class="keyword">this</span>.joinColumns(knex);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>If this is a single relation and we&#39;re not eager loading,
limit the query to a single item.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>.isSingle() &amp;&amp; !resp) knex.limit(<span class="number">1</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Finally, add (and validate) the where conditions, necessary for constraining the relation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">this</span>.whereClauses(knex, resp);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Inject &amp; validates necessary <code>through</code> constraints for the current model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    joinColumns: <span class="keyword">function</span>(knex) {
      <span class="keyword">var</span> columns = [];
      <span class="keyword">var</span> joinTable = <span class="keyword">this</span>.joinTable();
      <span class="keyword">if</span> (<span class="keyword">this</span>.isThrough()) {
        columns.push(<span class="keyword">this</span>.throughIdAttribute, <span class="keyword">this</span>.type === <span class="string">'belongsTo'</span> ? <span class="keyword">this</span>.key(<span class="string">'otherKey'</span>) : <span class="keyword">this</span>.key(<span class="string">'foreignKey'</span>));
        <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'belongsToMany'</span>) columns.push(<span class="keyword">this</span>.key(<span class="string">'otherKey'</span>));
      } <span class="keyword">else</span> {
        columns.push(<span class="keyword">this</span>.key(<span class="string">'foreignKey'</span>));
        <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'belongsToMany'</span>) columns.push(<span class="keyword">this</span>.key(<span class="string">'otherKey'</span>));
      }
      push.apply(columns, <span class="keyword">this</span>.pivotColumns);
      push.apply(knex.columns, _.map(columns, <span class="keyword">function</span>(col) {
        <span class="keyword">return</span> joinTable + <span class="string">'.'</span> + col + <span class="string">' as _pivot_'</span> + col;
      }));
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Generates the join clauses necessary for the current relation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    joinClauses: <span class="keyword">function</span>(knex) {
      <span class="keyword">var</span> joinTable = <span class="keyword">this</span>.joinTable();

      <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'belongsTo'</span> || <span class="keyword">this</span>.type === <span class="string">'belongsToMany'</span>) {
        knex.join(
          joinTable,
          joinTable + <span class="string">'.'</span> + <span class="keyword">this</span>.key(<span class="string">'otherKey'</span>), <span class="string">'='</span>,
          <span class="keyword">this</span>.targetTableName + <span class="string">'.'</span> + <span class="keyword">this</span>.targetIdAttribute
        );</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>A <code>belongsTo</code> -&gt; <code>through</code> is currently the only relation with two joins.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'belongsTo'</span>) {
          knex.join(
            <span class="keyword">this</span>.parentTableName,
            joinTable + <span class="string">'.'</span> + <span class="keyword">this</span>.throughIdAttribute, <span class="string">'='</span>,
            <span class="keyword">this</span>.parentTableName + <span class="string">'.'</span> + <span class="keyword">this</span>.key(<span class="string">'throughForeignKey'</span>)
          );
        }
      } <span class="keyword">else</span> {
        knex.join(
          joinTable,
          joinTable + <span class="string">'.'</span> + <span class="keyword">this</span>.throughIdAttribute, <span class="string">'='</span>,
          <span class="keyword">this</span>.targetTableName + <span class="string">'.'</span> + <span class="keyword">this</span>.key(<span class="string">'throughForeignKey'</span>)
        );
      }
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Check that there isn&#39;t an incorrect foreign key set, vs. the one
passed in when the relation was formed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    whereClauses: <span class="keyword">function</span>(knex, resp) {
      <span class="keyword">var</span> key;

      <span class="keyword">if</span> (<span class="keyword">this</span>.isJoined()) {
        <span class="keyword">var</span> targetTable = <span class="keyword">this</span>.type === <span class="string">'belongsTo'</span> ? <span class="keyword">this</span>.parentTableName : <span class="keyword">this</span>.joinTable();
        key = targetTable + <span class="string">'.'</span> + (<span class="keyword">this</span>.type === <span class="string">'belongsTo'</span> ? <span class="keyword">this</span>.parentIdAttribute : <span class="keyword">this</span>.key(<span class="string">'foreignKey'</span>));
      } <span class="keyword">else</span> {
        key = <span class="keyword">this</span>.isInverse() ? <span class="keyword">this</span>.parentIdAttribute : <span class="keyword">this</span>.key(<span class="string">'foreignKey'</span>);
      }

      knex[resp ? <span class="string">'whereIn'</span> : <span class="string">'where'</span>](key, resp ? <span class="keyword">this</span>.eagerKeys(resp) : <span class="keyword">this</span>.parentFk);

      <span class="keyword">if</span> (<span class="keyword">this</span>.isMorph()) {
        knex.where(<span class="keyword">this</span>.key(<span class="string">'morphKey'</span>), <span class="keyword">this</span>.key(<span class="string">'morphValue'</span>));
      }
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Fetches all <code>eagerKeys</code> from the current relation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    eagerKeys: <span class="keyword">function</span>(resp) {
      <span class="keyword">return</span> _.uniq(_.pluck(resp, <span class="keyword">this</span>.isInverse() ? <span class="keyword">this</span>.key(<span class="string">'otherKey'</span>) : <span class="keyword">this</span>.parentIdAttribute));
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Generates the appropriate standard join table.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    joinTable: <span class="keyword">function</span>() {
      <span class="keyword">if</span> (<span class="keyword">this</span>.isThrough()) <span class="keyword">return</span> <span class="keyword">this</span>.throughTableName;
      <span class="keyword">return</span> <span class="keyword">this</span>.joinTableName || [
        <span class="keyword">this</span>.parentTableName,
        <span class="keyword">this</span>.targetTableName
      ].sort().join(<span class="string">'_'</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Creates a new model or collection instance, depending on
the <code>relatedData</code> settings and the models passed in.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    relatedInstance: <span class="keyword">function</span>(models) {
      models || (models = []);

      <span class="keyword">var</span> Target = <span class="keyword">this</span>.target;
      <span class="keyword">if</span> (<span class="keyword">this</span>.isSingle()) {
        <span class="keyword">if</span> (!(Target.prototype <span class="keyword">instanceof</span> ModelBase)) {
          <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'The `'</span>+<span class="keyword">this</span>.type+<span class="string">'` related object must be a Bookshelf.Model'</span>);
        }
        <span class="keyword">return</span> models[<span class="number">0</span>] || <span class="keyword">new</span> Target();
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Allows us to just use a model, but create a temporary collection for
a <code>hasMany</code> or <code>belongsToMany</code> relation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (Target.prototype <span class="keyword">instanceof</span> ModelBase) {
        Target = <span class="keyword">this</span>.Collection.extend({
          model: Target,
          builder: Target.prototype.builder
        });
      }
      <span class="keyword">return</span> <span class="keyword">new</span> Target(models, {parse: <span class="literal">true</span>});
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Creates a new model, used internally in the eager fetch helper methods.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    createModel: <span class="keyword">function</span>(data) {
      <span class="keyword">if</span> (<span class="keyword">this</span>.target.prototype <span class="keyword">instanceof</span> CollectionBase) {
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.target.prototype.model(data, {parse: <span class="literal">true</span>})._reset();
      }
      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.target(data, {parse: <span class="literal">true</span>})._reset();
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Groups the related response according to the type of relationship
we&#39;re handling, for easy attachment to the parent models.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    eagerPair: <span class="keyword">function</span>(relationName, related, models) {</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>If this is a <code>through</code> or <code>belongsToMany</code> relation, we need to cleanup &amp; setup the <code>interim</code> model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>.isJoined()) related = <span class="keyword">this</span>.parsePivot(related);

      <span class="keyword">var</span> grouped = _.groupBy(related, <span class="keyword">function</span>(model) {
        <span class="keyword">return</span> <span class="keyword">this</span>.isSingle() ? model.id : (model.pivot ?
          model.pivot.get(<span class="keyword">this</span>.key(<span class="string">'foreignKey'</span>)) : model.get(<span class="keyword">this</span>.key(<span class="string">'foreignKey'</span>)));
      }, <span class="keyword">this</span>);

      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = models.length; i &lt; l; i++) {
        <span class="keyword">var</span> model = models[i];
        <span class="keyword">var</span> groupedKey = <span class="keyword">this</span>.isInverse() ? model.get(<span class="keyword">this</span>.key(<span class="string">'otherKey'</span>)) : model.id;
        model.relations[relationName] = <span class="keyword">this</span>.relatedInstance(grouped[groupedKey]);
      }
      <span class="keyword">return</span> related;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>The <code>models</code> is an array of models returned from the fetch,
after they&#39;re <code>set</code>... parsing out any of the <code>_pivot_</code> items from the
join table and assigning them on the pivot model or object as appropriate.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    parsePivot: <span class="keyword">function</span>(models) {
      <span class="keyword">var</span> Through = <span class="keyword">this</span>.throughTarget;
      <span class="keyword">return</span> _.map(models, <span class="keyword">function</span>(model) {
        <span class="keyword">var</span> data = {}, attrs = model.attributes, through;
        <span class="keyword">if</span> (Through) through = <span class="keyword">new</span> Through();
        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> attrs) {
          <span class="keyword">if</span> (key.indexOf(<span class="string">'_pivot_'</span>) === <span class="number">0</span>) {
            data[key.slice(<span class="number">7</span>)] = attrs[key];
            <span class="keyword">delete</span> attrs[key];
          }
        }
        <span class="keyword">if</span> (!_.isEmpty(data)) {
          model.pivot = through ? through.set(data, {silent: <span class="literal">true</span>}) : <span class="keyword">new</span> <span class="keyword">this</span>.Model(data, {
            tableName: <span class="keyword">this</span>.joinTable()
          });
        }
        <span class="keyword">return</span> model;
      }, <span class="keyword">this</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>A few predicates to help clarify some of the logic above.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    isThrough: <span class="keyword">function</span>() {
      <span class="keyword">return</span> (<span class="keyword">this</span>.throughTarget != <span class="literal">null</span>);
    },
    isJoined: <span class="keyword">function</span>() {
      <span class="keyword">return</span> (<span class="keyword">this</span>.type === <span class="string">'belongsToMany'</span> || <span class="keyword">this</span>.isThrough());
    },
    isMorph: <span class="keyword">function</span>() {
      <span class="keyword">return</span> (<span class="keyword">this</span>.type === <span class="string">'morphOne'</span> || <span class="keyword">this</span>.type === <span class="string">'morphMany'</span>);
    },
    isSingle: <span class="keyword">function</span>() {
      <span class="keyword">var</span> type = <span class="keyword">this</span>.type;
      <span class="keyword">return</span> (type === <span class="string">'hasOne'</span> || type === <span class="string">'belongsTo'</span> || type === <span class="string">'morphOne'</span> || type === <span class="string">'morphTo'</span>);
    },
    isInverse: <span class="keyword">function</span>() {
      <span class="keyword">return</span> (<span class="keyword">this</span>.type === <span class="string">'belongsTo'</span> || <span class="keyword">this</span>.type === <span class="string">'morphTo'</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Sets the <code>pivotColumns</code> to be retrieved along with the current model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    withPivot: <span class="keyword">function</span>(columns) {
      <span class="keyword">if</span> (!_.isArray(columns)) columns = [columns];
      <span class="keyword">this</span>.pivotColumns || (<span class="keyword">this</span>.pivotColumns = []);
      push.apply(<span class="keyword">this</span>.pivotColumns, columns);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Creates a new relation instance, used by the <code>Eager</code> relation in
dealing with <code>morphTo</code> cases, where the same relation is targeting multiple models.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    instance: <span class="keyword">function</span>(type, Target, options) {
      <span class="keyword">return</span> <span class="keyword">new</span> Relation(type, Target, options, <span class="keyword">this</span>.Model, <span class="keyword">this</span>.Collection);
    }
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Specific to many-to-many relationships, these methods are mixed
into the <code>belongsToMany</code> relationships when they are created,
providing helpers for attaching and detaching related models.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> pivotHelpers = {</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Attach one or more &quot;ids&quot; from a foreign
table to the current. Creates &amp; saves a new model
and attaches the model with a join table entry.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    attach: <span class="keyword">function</span>(ids, options) {
      <span class="keyword">return</span> <span class="keyword">this</span>._handler(<span class="string">'insert'</span>, ids, options);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Detach related object from their pivot tables.
If a model or id is passed, it attempts to remove the
pivot table based on that foreign key. If a hash is passed,
it attempts to remove the item based on a where clause with
these parameters. If no parameters are specified, we assume we will
detach all related associations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    detach: <span class="keyword">function</span>(ids, options) {
      <span class="keyword">return</span> <span class="keyword">this</span>._handler(<span class="string">'delete'</span>, ids, options);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Selects any additional columns on the pivot table,
taking a hash of columns which specifies the pivot
column name, and the value the column should take on the
output to the model attributes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    withPivot: <span class="keyword">function</span>(columns) {
      <span class="keyword">this</span>.relatedData.withPivot(columns);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Helper for handling either the <code>attach</code> or <code>detach</code> call on
the <code>belongsToMany</code> or <code>hasOne</code> / <code>hasMany</code> :through relationship.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _handler: <span class="keyword">function</span>(method, ids, options) {
      <span class="keyword">var</span> pending = [];
      <span class="keyword">if</span> (ids == <span class="keyword">void</span> <span class="number">0</span>) {
        <span class="keyword">if</span> (method === <span class="string">'insert'</span>) <span class="keyword">return</span> when.resolve(<span class="keyword">this</span>);
        <span class="keyword">if</span> (method === <span class="string">'delete'</span>) pending.push(<span class="keyword">this</span>._processPivot(method, <span class="literal">null</span>, options));
      }
      <span class="keyword">if</span> (!_.isArray(ids)) ids = ids ? [ids] : [];
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = ids.length; i &lt; l; i++) {
        pending.push(<span class="keyword">this</span>._processPivot(method, ids[i], options));
      }
      <span class="keyword">var</span> collection = <span class="keyword">this</span>;
      <span class="keyword">return</span> when.all(pending).then(<span class="keyword">function</span>() {
        <span class="keyword">return</span> collection;
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Handles setting the appropriate constraints and shelling out
to either the <code>insert</code> or <code>delete</code> call for the current model,
returning a promise.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _processPivot: <span class="keyword">function</span>(method, item, options) {
      <span class="keyword">var</span> data = {};
      <span class="keyword">var</span> relatedData = <span class="keyword">this</span>.relatedData;
      data[relatedData.key(<span class="string">'foreignKey'</span>)] = relatedData.parentFk;</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>If the item is an object, it&#39;s either a model
that we&#39;re looking to attach to this model, or
a hash of attributes to set in the relation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (_.isObject(item)) {
        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> ModelBase) {
          data[relatedData.key(<span class="string">'otherKey'</span>)] = item.id;
        } <span class="keyword">else</span> {
          _.extend(data, item);
        }
      } <span class="keyword">else</span> <span class="keyword">if</span> (item) {
        data[relatedData.key(<span class="string">'otherKey'</span>)] = item;
      }
      <span class="keyword">var</span> builder = <span class="keyword">this</span>.builder(relatedData.joinTable());
      <span class="keyword">if</span> (options &amp;&amp; options.transacting) {
        builder.transacting(options.transacting);
      }
      <span class="keyword">if</span> (method === <span class="string">'delete'</span>) <span class="keyword">return</span> builder.where(data).del();
      <span class="keyword">return</span> builder.insert(data);
    }
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Simple memoization of the singularize call.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> singularMemo = (<span class="keyword">function</span>() {
    <span class="keyword">var</span> cache = Object.create(<span class="literal">null</span>);
    <span class="keyword">return</span> <span class="keyword">function</span>(arg) {
      <span class="keyword">if</span> (arg <span class="keyword">in</span> cache) {
        <span class="keyword">return</span> cache[arg];
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> cache[arg] = inflection.singularize(arg);
      }
    };
  }());

  exports.Relation = Relation;

});

})(
  <span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd ? define : <span class="function"><span class="keyword">function</span> <span class="params">(factory)</span> {</span> factory(require, exports, module); }
);</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
