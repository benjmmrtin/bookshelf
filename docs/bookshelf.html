<!DOCTYPE html>

<html>
<head>
  <title>bookshelf.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>bookshelf.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <pre><code>Bookshelf.js 0.3.0

(c) 2013 Tim Griesser
Bookshelf may be freely distributed under the MIT license.
For all details and documentation:
http://bookshelfjs.org</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="keyword">function</span>(define) {

<span class="string">"use strict"</span>;

define(<span class="keyword">function</span>(require, exports) {</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2>Initial Setup</h2>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> Bookshelf   = exports;
  <span class="keyword">var</span> Backbone    = require(<span class="string">'backbone'</span>);
  <span class="keyword">var</span> knex        = require(<span class="string">'knex'</span>);
  <span class="keyword">var</span> _           = require(<span class="string">'underscore'</span>);
  <span class="keyword">var</span> when        = require(<span class="string">'when'</span>);
  <span class="keyword">var</span> inflection  = require(<span class="string">'inflection'</span>);
  <span class="keyword">var</span> triggerThen = require(<span class="string">'trigger-then'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Keep a reference to our own copy of Backbone, in case we want to use
this specific instance elsewhere in the application.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Bookshelf.Backbone = Backbone;</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Mixin the <code>triggerThen</code> function into all relevant Backbone objects,
so we can have event driven async validations, functions, etc.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  triggerThen(Backbone, when);</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Keep in sync with <code>package.json</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Bookshelf.VERSION = <span class="string">'0.3.0'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>We&#39;re using <code>Backbone.Events</code> rather than <code>EventEmitter</code>,
for consistency and portability.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> Events = Bookshelf.Events = Backbone.Events;</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p><code>Bookshelf</code> may be used as a top-level pub-sub bus.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _.extend(Bookshelf, Events);</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Array helpers used throughout.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> array  = [];
  <span class="keyword">var</span> push   = array.push;
  <span class="keyword">var</span> splice = array.splice;</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h2>Bookshelf.Model</h2>

            </div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>A Bookshelf Model represents an individual row in the database table --
It has a similar implementation to the <code>Backbone.Model</code>
constructor, except that defaults are not set until the
object is persisted, and the collection property is not used.</p>
<p>A unique <code>cid</code> property is also added to each created model, similar to
<code>Backbone</code> models, and is useful checking the identity of two models.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> Model = Bookshelf.Model = <span class="keyword">function</span>(attributes, options) {
    <span class="keyword">var</span> attrs = attributes || {};
    options || (options = {});
    <span class="keyword">this</span>.attributes = Object.create(<span class="literal">null</span>);
    <span class="keyword">this</span>._reset();
    <span class="keyword">this</span>.relations = {};
    <span class="keyword">this</span>.cid  = _.uniqueId(<span class="string">'c'</span>);
    <span class="keyword">if</span> (options) {
      _.extend(<span class="keyword">this</span>, _.pick(options, modelProps));
      <span class="keyword">if</span> (options.parse) attrs = <span class="keyword">this</span>.parse(attrs, options) || {};
    }
    <span class="keyword">this</span>.set(attrs, options);
    <span class="keyword">this</span>.initialize.apply(<span class="keyword">this</span>, arguments);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>A list of properties that are omitted from the <code>Backbone.Model.prototype</code>, since we&#39;re not
handling validations, or tracking changes in the same fashion as <code>Backbone</code>, we can drop these
specific methods.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> modelOmitted = [<span class="string">'changedAttributes'</span>, <span class="string">'isValid'</span>, <span class="string">'validationError'</span>, <span class="string">'_validate'</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>List of attributes attached directly from the <code>options</code> passed to the constructor.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> modelProps = [<span class="string">'tableName'</span>, <span class="string">'hasTimestamps'</span>];

  _.extend(Model.prototype, _.omit(Backbone.Model.prototype, modelOmitted), Events, {</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>The <code>hasOne</code> relation specifies that this table has exactly one of another type of object,
specified by a foreign key in the other table. The foreign key is assumed to be the singular of this
object&#39;s <code>tableName</code> with an <code>_id</code> suffix, but a custom <code>foreignKey</code> attribute may also be specified.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    hasOne: <span class="keyword">function</span>(Target, foreignKey) {
      <span class="keyword">return</span> <span class="keyword">new</span> Relation(<span class="string">'hasOne'</span>, Target, {foreignKey: foreignKey}).init(<span class="keyword">this</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>The <code>hasMany</code> relation specifies that this object has one or more rows in another table which
match on this object&#39;s primary key. The foreign key is assumed to be the singular of this object&#39;s
<code>tableName</code> with an <code>_id</code> suffix, but a custom <code>foreignKey</code> attribute may also be specified.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    hasMany: <span class="keyword">function</span>(Target, foreignKey) {
      <span class="keyword">return</span> <span class="keyword">new</span> Relation(<span class="string">'hasMany'</span>, Target, {foreignKey: foreignKey}).init(<span class="keyword">this</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>A reverse <code>hasOne</code> relation, the <code>belongsTo</code>, where the specified key in this table
matches the primary <code>idAttribute</code> of another table.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    belongsTo: <span class="keyword">function</span>(Target, foreignKey) {
      <span class="keyword">return</span> <span class="keyword">new</span> Relation(<span class="string">'belongsTo'</span>, Target, {foreignKey: foreignKey}).init(<span class="keyword">this</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>A <code>belongsToMany</code> relation is when there are many-to-many relation
between two models, with a joining table.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    belongsToMany: <span class="keyword">function</span>(Target, joinTableName, foreignKey, otherKey) {
      <span class="keyword">return</span> <span class="keyword">new</span> Relation(<span class="string">'belongsToMany'</span>, Target, {
        joinTableName: joinTableName, foreignKey: foreignKey, otherKey: otherKey
      }).init(<span class="keyword">this</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>A <code>morphOne</code> relation is a one-to-one polymorphic association from this model
to another model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    morphOne: <span class="keyword">function</span>(Target, name, morphValue) {
      <span class="keyword">return</span> <span class="keyword">this</span>._morphOneOrMany(Target, name, morphValue, <span class="string">'morphOne'</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>A <code>morphMany</code> relation is a polymorphic many-to-one relation from this model
to many another models.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    morphMany: <span class="keyword">function</span>(Target, name, morphValue) {
      <span class="keyword">return</span> <span class="keyword">this</span>._morphOneOrMany(Target, name, morphValue, <span class="string">'morphMany'</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Defines the opposite end of a <code>morphOne</code> or <code>morphMany</code> relationship, where
the alternate end of the polymorphic model is defined.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    morphTo: <span class="keyword">function</span>(morphName) {
      <span class="keyword">if</span> (!_.isString(morphName)) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'The `morphTo` name must be specified.'</span>);
      <span class="keyword">return</span> <span class="keyword">new</span> Relation(<span class="string">'morphTo'</span>, <span class="literal">null</span>, {morphName: morphName, candidates: _.rest(arguments)}).init(<span class="keyword">this</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Used to define passthrough relationships - <code>hasOne</code>, <code>hasMany</code>,
<code>belongsTo</code> or <code>belongsToMany</code>, &quot;through&quot; a <code>Interim</code> model or collection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    through: <span class="keyword">function</span>(Interim, foreignKey, otherKey) {
      <span class="keyword">return</span> <span class="keyword">this</span>.relatedData.through(<span class="keyword">this</span>, Interim, {throughForeignKey: foreignKey, otherKey: otherKey});
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Fetch a model based on the currently set attributes,
returning a model to the callback, along with any options.
Returns a deferred promise through the <code>Bookshelf.Sync</code>.
If <code>{require: true}</code> is set as an option, the fetch is considered
a failure if the model comes up blank.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    fetch: <span class="keyword">function</span>(options) {
      options || (options = {});
      <span class="keyword">var</span> model = <span class="keyword">this</span>, relatedData = <span class="keyword">this</span>.relatedData;
      <span class="keyword">return</span> <span class="keyword">this</span>.sync(options)
        .first()
        .then(<span class="keyword">function</span>(response) {
          <span class="keyword">if</span> (response &amp;&amp; response.length &gt; <span class="number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Todo: {silent: true, parse: true}, for parity with collection#set
need to check on Backbone&#39;s status there, ticket #2636</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            model.set(model.parse(response[<span class="number">0</span>]), {silent: <span class="literal">true</span>})._reset();

            <span class="keyword">if</span> (relatedData &amp;&amp; relatedData.isJoined()) {
              relatedData.parsePivot([model]);
            }

            <span class="keyword">if</span> (!options.withRelated) <span class="keyword">return</span> response;
            <span class="keyword">return</span> <span class="keyword">new</span> EagerRelation([model], response, model)
              .fetch(options)
              .then(<span class="keyword">function</span>() { <span class="keyword">return</span> response; });
          }
          <span class="keyword">if</span> (options.require) <span class="keyword">return</span> when.reject(<span class="keyword">new</span> Error(<span class="string">'EmptyResponse'</span>));
        })
        .then(<span class="keyword">function</span>(response) {
          <span class="keyword">if</span> (response &amp;&amp; response.length &gt; <span class="number">0</span>) {
            <span class="keyword">return</span> model.triggerThen(<span class="string">'fetched'</span>, model, response, options).then(<span class="keyword">function</span>() {
              <span class="keyword">return</span> model;
            });
          }
          <span class="keyword">return</span> <span class="literal">null</span>;
        });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Eager loads relationships onto an already populated <code>Model</code> instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    load: <span class="keyword">function</span>(relations, options) {
      <span class="keyword">var</span> model = <span class="keyword">this</span>;
      _.isArray(relations) || (relations = [relations]);
      options = _.extend({}, options, {shallow: <span class="literal">true</span>, withRelated: relations});
      <span class="keyword">return</span> <span class="keyword">new</span> EagerRelation([<span class="keyword">this</span>], [<span class="keyword">this</span>.toJSON(options)], <span class="keyword">this</span>)
        .fetch(options)
        .then(<span class="keyword">function</span>() { <span class="keyword">return</span> model; });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Similar to the standard <code>Backbone</code> set method, but without individual
change events, and adding different meaning to <code>changed</code> and <code>previousAttributes</code>
defined as the last &quot;sync&quot;&#39;ed state of the model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    set: <span class="keyword">function</span>(key, val, options) {
      <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">this</span>;
      <span class="keyword">var</span> attrs;</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Handle both <code>&quot;key&quot;, value</code> and <code>{key: value}</code> -style arguments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">'object'</span>) {
        attrs = key;
        options = val;
      } <span class="keyword">else</span> {
        (attrs = {})[key] = val;
      }
      options || (options = {});</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Extract attributes and options.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> hasChanged = <span class="literal">false</span>;
      <span class="keyword">var</span> unset   = options.unset;
      <span class="keyword">var</span> current = <span class="keyword">this</span>.attributes;
      <span class="keyword">var</span> prev    = <span class="keyword">this</span>._previousAttributes;</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Check for changes of <code>id</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>.idAttribute <span class="keyword">in</span> attrs) <span class="keyword">this</span>.id = attrs[<span class="keyword">this</span>.idAttribute];</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>For each <code>set</code> attribute, update or delete the current value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> attrs) {
        val = attrs[attr];
        <span class="keyword">if</span> (!_.isEqual(prev[attr], val)) {
          <span class="keyword">this</span>.changed[attr] = val;
          <span class="keyword">if</span> (!_.isEqual(current[attr], val)) hasChanged = <span class="literal">true</span>;
        } <span class="keyword">else</span> {
          <span class="keyword">delete</span> <span class="keyword">this</span>.changed[attr];
        }
        unset ? <span class="keyword">delete</span> current[attr] : current[attr] = val;
      }

      <span class="keyword">if</span> (hasChanged &amp;&amp; !options.silent) <span class="keyword">this</span>.trigger(<span class="string">'change'</span>, <span class="keyword">this</span>, options);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Sets and saves the hash of model attributes, triggering
a &quot;creating&quot; or &quot;updating&quot; event on the model, as well as a &quot;saving&quot; event,
to bind listeners for any necessary validation, logging, etc.
If an error is thrown during these events, the model will not be saved.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    save: <span class="keyword">function</span>(key, val, options) {
      <span class="keyword">var</span> attrs;</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Handle both <code>&quot;key&quot;, value</code> and <code>{key: value}</code> -style arguments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (key == <span class="literal">null</span> || <span class="keyword">typeof</span> key === <span class="string">"object"</span>) {
        attrs = key || {};
        options = val || {};
      } <span class="keyword">else</span> {
        options || (options = {});
        (attrs = {})[key] = val;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>If the model has timestamp columns,
set them as attributes on the model, even
if the &quot;patch&quot; option is specified.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>.hasTimestamps) _.extend(attrs, <span class="keyword">this</span>.timestamp(options));</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Determine whether the model is new, based on whether the model has an <code>idAttribute</code> or not.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> method = options.method || (options.method = <span class="keyword">this</span>.isNew(options) ? <span class="string">'insert'</span> : <span class="string">'update'</span>);
      <span class="keyword">var</span> vals = attrs;</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>If the object is being created, we merge any defaults here
rather than during object creation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (method === <span class="string">'insert'</span> || options.defaults) {
        <span class="keyword">var</span> defaults = _.result(<span class="keyword">this</span>, <span class="string">'defaults'</span>);
        <span class="keyword">if</span> (defaults) {
          vals = _.extend({}, defaults, <span class="keyword">this</span>.attributes, vals);
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Set the attributes on the model, and maintain a reference to use below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> model = <span class="keyword">this</span>.set(vals, {silent: <span class="literal">true</span>});</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>If there are any save constraints, set them on the model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>.relatedData) <span class="keyword">this</span>.relatedData.saveConstraints(<span class="keyword">this</span>);

      <span class="keyword">var</span> sync  = <span class="keyword">this</span>.sync(options);</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Gives access to the <code>query</code> object in the <code>options</code>, in case we need it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      options.query = sync.query;

      <span class="keyword">return</span> when.all([
        model.triggerThen((method === <span class="string">'insert'</span> ? <span class="string">'creating'</span> : <span class="string">'updating'</span>), model, attrs, options),
        model.triggerThen(<span class="string">'saving'</span>, model, attrs, options)
      ])
      .then(<span class="keyword">function</span>() {
        <span class="keyword">return</span> sync[options.method](method === <span class="string">'update'</span> &amp;&amp; options.patch ? attrs : model.attributes);
      })
      .then(<span class="keyword">function</span>(resp) {</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>After a successful database save, the id is updated if the model was created</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (method === <span class="string">'insert'</span> &amp;&amp; resp) {
          model.attributes[model.idAttribute] = model[model.idAttribute] = resp[<span class="number">0</span>];
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>In case we need to reference the <code>previousAttributes</code> for the model
in the following event handlers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        options.previousAttributes = model._previousAttributes;

        model._reset();

        <span class="keyword">return</span> when.all([
          model.triggerThen((method === <span class="string">'insert'</span> ? <span class="string">'created'</span> : <span class="string">'updated'</span>), model, resp, options),
          model.triggerThen(<span class="string">'saved'</span>, model, resp, options)
        ]);

      }).then(<span class="keyword">function</span>() {
        <span class="keyword">return</span> model;
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Destroy a model, calling a &quot;delete&quot; based on its <code>idAttribute</code>.
A &quot;destroying&quot; and &quot;destroyed&quot; are triggered on the model before
and after the model is destroyed, respectively. If an error is thrown
during the &quot;destroying&quot; event, the model will not be destroyed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    destroy: <span class="keyword">function</span>(options) {
      options || (options = {});
      <span class="keyword">var</span> model = <span class="keyword">this</span>;
      <span class="keyword">return</span> model.triggerThen(<span class="string">'destroying'</span>, model, options)
      .then(<span class="keyword">function</span>() { <span class="keyword">return</span> model.sync(options).del(); })
      .then(<span class="keyword">function</span>(resp) {
        model.clear();
        <span class="keyword">return</span> model.triggerThen(<span class="string">'destroyed'</span>, model, resp, options).then(<span class="keyword">function</span>() {
          <span class="keyword">return</span> model._reset();
        });
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p><strong>format</strong> converts a model into the values that should be saved into
the database table. The default implementation is just to pass the response along.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    format: <span class="keyword">function</span>(attrs, options) {
      <span class="keyword">return</span> attrs;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Returns an object containing a shallow copy of the model attributes,
along with the <code>toJSON</code> value of any relations,
unless <code>{shallow: true}</code> is passed in the <code>options</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    toJSON: <span class="keyword">function</span>(options) {
      <span class="keyword">var</span> attrs = _.extend({}, <span class="keyword">this</span>.attributes);
      <span class="keyword">if</span> (options &amp;&amp; options.shallow) <span class="keyword">return</span> attrs;
      <span class="keyword">var</span> relations = <span class="keyword">this</span>.relations;
      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> relations) {
        <span class="keyword">var</span> relation = relations[key];
        attrs[key] = relation.toJSON ? relation.toJSON() : relation;
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.pivot) {
        <span class="keyword">var</span> pivot = <span class="keyword">this</span>.pivot.attributes;
        <span class="keyword">for</span> (key <span class="keyword">in</span> pivot) {
          attrs[<span class="string">'_pivot_'</span> + key] = pivot[key];
        }
      }
      <span class="keyword">return</span> attrs;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Sets the timestamps before saving the model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    timestamp: <span class="keyword">function</span>(options) {
      <span class="keyword">var</span> d = <span class="keyword">new</span> Date();
      <span class="keyword">var</span> keys = (_.isArray(<span class="keyword">this</span>.hasTimestamps) ? <span class="keyword">this</span>.hasTimestamps : [<span class="string">'created_at'</span>, <span class="string">'updated_at'</span>]);
      <span class="keyword">var</span> vals = {};
      vals[keys[<span class="number">1</span>]] = d;
      <span class="keyword">if</span> (<span class="keyword">this</span>.isNew(options) &amp;&amp; (!options || options.method !== <span class="string">'update'</span>)) vals[keys[<span class="number">0</span>]] = d;
      <span class="keyword">return</span> vals;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Create a new model with identical attributes to this one,
including any relations on the current model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    clone: <span class="keyword">function</span>() {
      <span class="keyword">var</span> model = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="keyword">this</span>.attributes);
      <span class="keyword">var</span> relations = <span class="keyword">this</span>.relations;
      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> relations) {
        model.relations[key] = relations[key].clone();
      }
      model._previousAttributes = _.clone(<span class="keyword">this</span>._previousAttributes);
      model.changed = _.clone(<span class="keyword">this</span>.changed);
      <span class="keyword">return</span> model;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Returns the related item, or creates a new
related item by creating a new model or collection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    related: <span class="keyword">function</span>(name) {
      <span class="keyword">return</span> <span class="keyword">this</span>.relations[name] || (<span class="keyword">this</span>[name] ? <span class="keyword">this</span>.relations[name] = <span class="keyword">this</span>[name]() : <span class="keyword">void</span> <span class="number">0</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Reset the query builder, called internally
each time a query is run.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    resetQuery: <span class="keyword">function</span>() {
      <span class="keyword">delete</span> <span class="keyword">this</span>._knex;
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Returns an instance of the query builder.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    query: <span class="keyword">function</span>() {
      <span class="keyword">return</span> query(<span class="keyword">this</span>, _.toArray(arguments));
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Returns a <code>knex</code> instance with the specified table name.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    builder: <span class="keyword">function</span>(table) {
      <span class="keyword">return</span> knex(table);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>Creates and returns a new <code>Bookshelf.Sync</code> instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    sync: <span class="keyword">function</span>(options) {
      <span class="keyword">return</span> <span class="keyword">new</span> Bookshelf.Sync(<span class="keyword">this</span>, options);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Helper for setting up the <code>morphOne</code> or <code>morphMany</code> relations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _morphOneOrMany: <span class="keyword">function</span>(Target, morphName, morphValue, type) {
      <span class="keyword">if</span> (!morphName || !Target) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'The polymorphic `name` and `Target` are required.'</span>);
      <span class="keyword">return</span> <span class="keyword">new</span> Relation(type, Target, {morphName: morphName, morphValue: morphValue}).init(<span class="keyword">this</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>Called after a <code>sync</code> action (save, fetch, delete) -
resets the <code>_previousAttributes</code> and <code>changed</code> hash for the model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _reset: <span class="keyword">function</span>() {
      <span class="keyword">this</span>._previousAttributes = _.extend(Object.create(<span class="literal">null</span>), <span class="keyword">this</span>.attributes);
      <span class="keyword">this</span>.changed = Object.create(<span class="literal">null</span>);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    }

  });</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <h2>Bookshelf.Collection</h2>

            </div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>A Bookshelf Collection contains a number of database rows, represented by
models, so they can be easily sorted, serialized, and manipulated.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> Collection = Bookshelf.Collection = <span class="keyword">function</span>(models, options) {
    <span class="keyword">if</span> (options) _.extend(<span class="keyword">this</span>, _.pick(options, collectionProps));
    <span class="keyword">this</span>._reset();
    <span class="keyword">this</span>.initialize.apply(<span class="keyword">this</span>, arguments);
    <span class="keyword">if</span> (models) <span class="keyword">this</span>.reset(models, _.extend({silent: <span class="literal">true</span>}, options));
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>List of attributes attached directly from the constructor&#39;s options object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> collectionProps = [<span class="string">'model'</span>, <span class="string">'comparator'</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Copied over from Backbone.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> setOptions = {add: <span class="literal">true</span>, remove: <span class="literal">true</span>, merge: <span class="literal">true</span>};</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Extend the Collection&#39;s prototype with the base methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _.extend(Collection.prototype, _.omit(Backbone.Collection.prototype, <span class="string">'model'</span>), Events, {

    model: Model,</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Used to define passthrough relationships - <code>hasOne</code>, <code>hasMany</code>,
<code>belongsTo</code> or <code>belongsToMany</code>, &quot;through&quot; a <code>Interim</code> model or collection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    through: <span class="keyword">function</span>(Interim, foreignKey, otherKey) {
      <span class="keyword">return</span> <span class="keyword">this</span>.relatedData.through(<span class="keyword">this</span>, Interim, {throughForeignKey: foreignKey, otherKey: otherKey});
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>A simplified version of Backbone&#39;s <code>Collection#set</code> method,
removing the comparator, and getting rid of the temporary model creation,
since there&#39;s <em>no way</em> we&#39;ll be getting the data in an inconsistent
form from the database.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    set: <span class="keyword">function</span>(models, options) {
      options = _.defaults({}, options, setOptions);
      <span class="keyword">if</span> (options.parse) models = <span class="keyword">this</span>.parse(models, options);
      <span class="keyword">if</span> (!_.isArray(models)) models = models ? [models] : [];
      <span class="keyword">var</span> i, l, id, model, attrs, existing;
      <span class="keyword">var</span> at = options.at;
      <span class="keyword">var</span> targetModel = <span class="keyword">this</span>.model;
      <span class="keyword">var</span> toAdd = [], toRemove = [], modelMap = {};
      <span class="keyword">var</span> add = options.add, merge = options.merge, remove = options.remove;
      <span class="keyword">var</span> order = add &amp;&amp; remove ? [] : <span class="literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>Turn bare objects into model references, and prevent invalid models
from being added.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">for</span> (i = <span class="number">0</span>, l = models.length; i &lt; l; i++) {
        attrs = models[i];
        <span class="keyword">if</span> (attrs <span class="keyword">instanceof</span> Model) {
          id = model = attrs;
        } <span class="keyword">else</span> {
          id = attrs[targetModel.prototype.idAttribute];
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>If a duplicate is found, prevent it from being added and
optionally merge it into the existing model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (existing = <span class="keyword">this</span>.get(id)) {
          <span class="keyword">if</span> (remove) {
            modelMap[existing.cid] = <span class="literal">true</span>;
            <span class="keyword">continue</span>;
          }
          <span class="keyword">if</span> (merge) {
            attrs = attrs === model ? model.attributes : attrs;
            <span class="keyword">if</span> (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>This is a new model, push it to the <code>toAdd</code> list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        } <span class="keyword">else</span> <span class="keyword">if</span> (add) {
          <span class="keyword">if</span> (!(model = <span class="keyword">this</span>._prepareModel(attrs, options))) <span class="keyword">continue</span>;
          toAdd.push(model);</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>Listen to added models&#39; events, and index models for lookup by
<code>id</code> and by <code>cid</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          model.on(<span class="string">'all'</span>, <span class="keyword">this</span>._onModelEvent, <span class="keyword">this</span>);
          <span class="keyword">this</span>._byId[model.cid] = model;
          <span class="keyword">if</span> (model.id != <span class="literal">null</span>) <span class="keyword">this</span>._byId[model.id] = model;
        }
        <span class="keyword">if</span> (order) order.push(existing || model);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>Remove nonexistent models if appropriate.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (remove) {
        <span class="keyword">for</span> (i = <span class="number">0</span>, l = <span class="keyword">this</span>.length; i &lt; l; ++i) {
          <span class="keyword">if</span> (!modelMap[(model = <span class="keyword">this</span>.models[i]).cid]) toRemove.push(model);
        }
        <span class="keyword">if</span> (toRemove.length) <span class="keyword">this</span>.remove(toRemove, options);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>See if sorting is needed, update <code>length</code> and splice in new models.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (toAdd.length || (order &amp;&amp; order.length)) {
        <span class="keyword">this</span>.length += toAdd.length;
        <span class="keyword">if</span> (at != <span class="literal">null</span>) {
          splice.apply(<span class="keyword">this</span>.models, [at, <span class="number">0</span>].concat(toAdd));
        } <span class="keyword">else</span> {
          <span class="keyword">if</span> (order) <span class="keyword">this</span>.models.length = <span class="number">0</span>;
          push.apply(<span class="keyword">this</span>.models, order || toAdd);
        }
      }

      <span class="keyword">if</span> (options.silent) <span class="keyword">return</span> <span class="keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>Trigger <code>add</code> events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">for</span> (i = <span class="number">0</span>, l = toAdd.length; i &lt; l; i++) {
        (model = toAdd[i]).trigger(<span class="string">'add'</span>, model, <span class="keyword">this</span>, options);
      }
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>Fetch the models for this collection, resetting the models
for the query when they arrive.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    fetch: <span class="keyword">function</span>(options) {
      options || (options = {});
      <span class="keyword">var</span> collection = <span class="keyword">this</span>, relatedData = <span class="keyword">this</span>.relatedData;
      <span class="keyword">return</span> <span class="keyword">this</span>.sync(options)
        .select()
        .then(<span class="keyword">function</span>(response) {
          <span class="keyword">if</span> (response &amp;&amp; response.length &gt; <span class="number">0</span>) {
            collection.set(response, {silent: <span class="literal">true</span>, parse: <span class="literal">true</span>}).invoke(<span class="string">'_reset'</span>);
            <span class="keyword">if</span> (relatedData &amp;&amp; relatedData.isJoined()) relatedData.parsePivot(collection.models);
          } <span class="keyword">else</span> {
            collection.reset([], {silent: <span class="literal">true</span>});
            <span class="keyword">return</span> [];
          }
          <span class="keyword">if</span> (!options.withRelated) <span class="keyword">return</span> response;
          <span class="keyword">return</span> <span class="keyword">new</span> EagerRelation(collection.models, response, <span class="keyword">new</span> collection.model())
            .fetch(options)
            .then(<span class="keyword">function</span>() { <span class="keyword">return</span> response; });
        })
        .then(<span class="keyword">function</span>(response) {
          <span class="keyword">return</span> collection.triggerThen(<span class="string">'fetched'</span>, collection, response, options).then(<span class="keyword">function</span>() {
            <span class="keyword">return</span> collection;
          });
        });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>Fetches a single model from the collection, useful on related collections.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    fetchOne: <span class="keyword">function</span>(options) {
      <span class="keyword">var</span> model = <span class="keyword">new</span> <span class="keyword">this</span>.model;
      model._knex = <span class="keyword">this</span>.query().clone();
      <span class="keyword">if</span> (<span class="keyword">this</span>.relatedData) model.relatedData = <span class="keyword">this</span>.relatedData;
      <span class="keyword">return</span> model.fetch(options);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>Eager loads relationships onto an already populated <code>Collection</code> instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    load: <span class="keyword">function</span>(relations, options) {
      <span class="keyword">var</span> collection = <span class="keyword">this</span>;
      _.isArray(relations) || (relations = [relations]);
      options = _.extend({}, options, {shallow: <span class="literal">true</span>, withRelated: relations});
      <span class="keyword">return</span> <span class="keyword">new</span> EagerRelation(<span class="keyword">this</span>.models, <span class="keyword">this</span>.toJSON(options), <span class="keyword">new</span> <span class="keyword">this</span>.model())
        .fetch(options)
        .then(<span class="keyword">function</span>() { <span class="keyword">return</span> collection; });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>Shortcut for creating a new model, saving, and adding to the collection.
Returns a promise which will resolve with the model added to the collection.
If the model is a relation, put the <code>foreignKey</code> and <code>fkValue</code> from the <code>relatedData</code>
hash into the inserted model. Also, if the model is a <code>manyToMany</code> relation,
automatically create the joining model upon insertion.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    create: <span class="keyword">function</span>(model, options) {
      options || (options = {});

      <span class="keyword">var</span> collection  = <span class="keyword">this</span>;
      <span class="keyword">var</span> relatedData = <span class="keyword">this</span>.relatedData || <span class="keyword">new</span> Relation();
      <span class="keyword">var</span> type        = relatedData.type;

      model = <span class="keyword">this</span>._prepareModel(model, options);</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>If we&#39;ve already added things on the query chain,
these are likely intended for the model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>._knex) {
        model._knex = <span class="keyword">this</span>._knex;
        <span class="keyword">this</span>.resetQuery();
      }

      <span class="keyword">return</span> relatedData
        .saveConstraints(model, <span class="keyword">this</span>)
        .save(<span class="literal">null</span>, options)
        .then(<span class="keyword">function</span>() {
          <span class="keyword">if</span> (type &amp;&amp; (type === <span class="string">'belongsToMany'</span> || relatedData.isThrough())) {
            <span class="keyword">return</span> collection.attach(model, options);
          }
        })
        .then(<span class="keyword">function</span>() {
          collection.add(model, options);
          <span class="keyword">return</span> model;
        });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>The <code>tableName</code> on the associated Model, used in relation building.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    tableName: <span class="keyword">function</span>() {
      <span class="keyword">return</span> _.result(<span class="keyword">this</span>.model.prototype, <span class="string">'tableName'</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>The <code>idAttribute</code> on the associated Model, used in relation building.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    idAttribute: <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.model.prototype.idAttribute;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>Reset the query builder, called internally
each time a query is run.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    resetQuery: <span class="keyword">function</span>() {
      <span class="keyword">delete</span> <span class="keyword">this</span>._knex;
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>Returns an instance of the query builder.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    query: <span class="keyword">function</span>() {
      <span class="keyword">return</span> query(<span class="keyword">this</span>, _.toArray(arguments));
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Returns a <code>knex</code> instance with the specified table name.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    builder: <span class="keyword">function</span>(table) {
      <span class="keyword">return</span> knex(table);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>Creates and returns a new <code>Bookshelf.Sync</code> instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    sync: <span class="keyword">function</span>(options) {
      <span class="keyword">return</span> <span class="keyword">new</span> Bookshelf.Sync(<span class="keyword">this</span>, options);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>Prepare a model or hash of attributes to be added to this collection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _prepareModel: <span class="keyword">function</span>(attrs, options) {
      <span class="keyword">if</span> (attrs <span class="keyword">instanceof</span> Model) <span class="keyword">return</span> attrs;
      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.model(attrs, options);
    }

  });</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <h2>Bookshelf.EagerRelation</h2>

            </div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>An <code>EagerRelation</code> object temporarily stores the models from an eager load,
and handles matching eager loaded objects with their parent(s). The <code>tempModel</code>
is only used to retrieve the value of the relation method, to know the constrains
for the eager query.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> EagerRelation = Bookshelf.EagerRelation = <span class="keyword">function</span>(parent, parentResponse, target) {
    <span class="keyword">this</span>.parent = parent;
    <span class="keyword">this</span>.target = target;
    <span class="keyword">this</span>.parentResponse = parentResponse;
    _.bindAll(<span class="keyword">this</span>, <span class="string">'pushModels'</span>, <span class="string">'eagerFetch'</span>);
  };

  EagerRelation.prototype = {</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>This helper function is used internally to determine which relations
are necessary for fetching based on the <code>model.load</code> or <code>withRelated</code> option.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    fetch: <span class="keyword">function</span>(options) {
      <span class="keyword">var</span> relationName, related, relation;
      <span class="keyword">var</span> target      = <span class="keyword">this</span>.target;
      <span class="keyword">var</span> handled     = <span class="keyword">this</span>.handled = {};
      <span class="keyword">var</span> withRelated = <span class="keyword">this</span>.prepWithRelated(options.withRelated);
      <span class="keyword">var</span> subRelated  = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>Internal flag to determine whether to set the ctor(s) on the <code>Relation</code> object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      target._isEager = <span class="literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>Eager load each of the <code>withRelated</code> relation item, splitting on &#39;.&#39;
which indicates a nested eager load.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> withRelated) {

        related = key.split(<span class="string">'.'</span>);
        relationName = related[<span class="number">0</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>Add additional eager items to an array, to load at the next level in the query.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (related.length &gt; <span class="number">1</span>) {
          <span class="keyword">var</span> relatedObj = {};
          subRelated[relationName] || (subRelated[relationName] = []);
          relatedObj[related.slice(<span class="number">1</span>).join(<span class="string">'.'</span>)] = withRelated[key];
          subRelated[relationName].push(relatedObj);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>Only allow one of a certain nested type per-level.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (handled[relationName]) <span class="keyword">continue</span>;

        relation = target[relationName]();

        <span class="keyword">if</span> (!relation) <span class="keyword">throw</span> <span class="keyword">new</span> Error(relationName + <span class="string">' is not defined on the model.'</span>);

        handled[relationName] = relation;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>Delete the internal flag from the model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">delete</span> target._isEager;</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>Fetch all eager loaded models, loading them onto
an array of pending deferred objects, which will handle
all necessary pairing with parent objects, etc.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> pendingDeferred = [];
      <span class="keyword">for</span> (relationName <span class="keyword">in</span> handled) {
        pendingDeferred.push(<span class="keyword">this</span>.eagerFetch(relationName, handled[relationName], _.extend({}, options, {
          isEager: <span class="literal">true</span>,
          withRelated: subRelated[relationName],
          beforeFn: withRelated[relationName] || noop
        })));
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>Return a deferred handler for all of the nested object sync
returning the original response when these syncs &amp; pairings are complete.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> eagerHandler = <span class="keyword">this</span>;
      <span class="keyword">return</span> when.all(pendingDeferred).then(<span class="keyword">function</span>() {
        <span class="keyword">return</span> eagerHandler.parentResponse;
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>Prep the <code>withRelated</code> object, to normalize into an object where each
has a function that is called when running the query.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    prepWithRelated: <span class="keyword">function</span>(withRelated) {
      <span class="keyword">if</span> (!_.isArray(withRelated)) withRelated = [withRelated];
      <span class="keyword">return</span> _.reduce(withRelated, <span class="keyword">function</span>(memo, item) {
        _.isString(item) ? memo[item] = noop : _.extend(memo, item);
        <span class="keyword">return</span> memo;
      }, {});
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>Handles an eager loaded fetch, passing the name of the item we&#39;re fetching for,
and any options needed for the current fetch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    eagerFetch: <span class="keyword">function</span>(relationName, handled, options) {
      <span class="keyword">var</span> relatedData = handled.relatedData;

      <span class="keyword">if</span> (relatedData.type === <span class="string">'morphTo'</span>) <span class="keyword">return</span> <span class="keyword">this</span>.morphToFetch(relationName, relatedData, options);</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>Call the function, if one exists, to constrain the eager loaded query.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      options.beforeFn.call(handled, handled.query());

      <span class="keyword">var</span> relation = <span class="keyword">this</span>;
      <span class="keyword">return</span> handled
        .sync(_.extend({}, options, {parentResponse: <span class="keyword">this</span>.parentResponse}))
        .select()
        .then(<span class="keyword">function</span>(resp) {
          <span class="keyword">var</span> relatedModels = relation.pushModels(relationName, handled, resp);</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>If there is a response, fetch additional nested eager relations, if any.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="keyword">if</span> (resp.length &gt; <span class="number">0</span> &amp;&amp; options.withRelated) {
            <span class="keyword">return</span> <span class="keyword">new</span> EagerRelation(relatedModels, resp, relatedData.createModel())
              .fetch(options)
              .then(<span class="keyword">function</span>() { <span class="keyword">return</span> resp; });
          }
          <span class="keyword">return</span> resp;
        });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>Special handler for the eager loaded morph-to relations, this handles
the fact that there are several potential models that we need to be fetching against.
pairing them up onto a single response for the eager loading.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    morphToFetch: <span class="keyword">function</span>(relationName, relatedData, options) {
      <span class="keyword">var</span> pending = [];
      <span class="keyword">var</span> groups = _.groupBy(<span class="keyword">this</span>.parent, <span class="keyword">function</span>(m) {
        <span class="keyword">return</span> m.get(relationName + <span class="string">'_type'</span>);
      });
      <span class="keyword">for</span> (<span class="keyword">var</span> group <span class="keyword">in</span> groups) {
        <span class="keyword">var</span> Target = morphCandidate(relatedData.candidates, group);
        <span class="keyword">var</span> target = <span class="keyword">new</span> Target();
        pending.push(target
          .query(<span class="string">'whereIn'</span>,
            _.result(target, <span class="string">'idAttribute'</span>), _.uniq(_.invoke(groups[group], <span class="string">'get'</span>, relationName + <span class="string">'_id'</span>))
          )
          .sync(options)
          .select()
          .then(<span class="keyword">this</span>.morphToHandler(relationName, relatedData, Target)));
      }
      <span class="keyword">return</span> when.all(pending).then(<span class="keyword">function</span>(resps) {
        <span class="keyword">return</span> _.flatten(resps);
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>Handler for the individual <code>morphTo</code> fetches,
attaching any of the related models onto the parent objects,
stopping at this level of the eager relation loading.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    morphToHandler: <span class="keyword">function</span>(relationName, settings, Target) {
      <span class="keyword">var</span> eager = <span class="keyword">this</span>;
      <span class="keyword">return</span> <span class="keyword">function</span>(resp) {
        eager.pushModels(relationName, {relatedData: <span class="keyword">new</span> Relation(<span class="string">'morphTo'</span>, Target, {morphName: relationName})}, resp);
      };
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>Pushes each of the incoming models onto a new <code>related</code> array,
which is used to correcly pair additional nested relations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    pushModels: <span class="keyword">function</span>(relationName, handled, resp) {
      <span class="keyword">var</span> models      = <span class="keyword">this</span>.parent;
      <span class="keyword">var</span> relatedData = handled.relatedData;
      <span class="keyword">var</span> related     = [];
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = resp.length; i &lt; l; i++) {
        related.push(relatedData.createModel(resp[i]));
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>If this is a morphTo, we only want to pair on the morphValue for the current relation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (relatedData.type === <span class="string">'morphTo'</span>) {
        models = _.filter(models, <span class="keyword">function</span>(model) { <span class="keyword">return</span> model.get(relatedData.key(<span class="string">'morphKey'</span>)) === relatedData.key(<span class="string">'morphValue'</span>); });
      }
      <span class="keyword">return</span> relatedData.eagerPair(relationName, related, models);
    }
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>Set up inheritance for the model and collection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Model.extend = Collection.extend = EagerRelation.extend = Bookshelf.Backbone.Model.extend;</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>The <code>forge</code> function properly instantiates a new Model or Collection
without needing the <code>new</code> operator... to make object creation cleaner
and more chainable.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Model.forge = Collection.forge = <span class="keyword">function</span>() {
    <span class="keyword">var</span> inst = Object.create(<span class="keyword">this</span>.prototype);
    <span class="keyword">var</span> obj = <span class="keyword">this</span>.apply(inst, arguments);
    <span class="keyword">return</span> (Object(obj) === obj ? obj : inst);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <h2>Bookshelf.Sync</h2>

            </div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>Sync is the dispatcher for any database queries,
taking the &quot;syncing&quot; <code>model</code> or <code>collection</code> being queried, along with
a hash of options that are used in the various query methods.
If the <code>transacting</code> option is set, the query is assumed to be
part of a transaction, and this information is passed along to <code>Knex</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> Sync = Bookshelf.Sync = <span class="keyword">function</span>(syncing, options) {
    options || (options = {});
    <span class="keyword">this</span>.query = syncing.query();
    <span class="keyword">this</span>.syncing = syncing.resetQuery();
    <span class="keyword">this</span>.options = options;
    <span class="keyword">if</span> (options.transacting) <span class="keyword">this</span>.query.transacting(options.transacting);
  };

  _.extend(Sync.prototype, {</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>Select the first item from the database - only used by models.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    first: <span class="keyword">function</span>() {
      <span class="keyword">var</span> syncing = <span class="keyword">this</span>.syncing;
      <span class="keyword">this</span>.query.where(syncing.format(_.extend(Object.create(<span class="literal">null</span>), syncing.attributes))).limit(<span class="number">1</span>);
      <span class="keyword">return</span> <span class="keyword">this</span>.select();
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>Runs a <code>select</code> query on the database, adding any necessary relational
constraints, resetting the query when complete. If there are results and
eager loaded relations, those are fetched and returned on the model before
the promise is resolved. Any <code>success</code> handler passed in the
options will be called - used by both models &amp; collections.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    select: <span class="keyword">function</span>() {
      <span class="keyword">var</span> columns, sync = <span class="keyword">this</span>, syncing = <span class="keyword">this</span>.syncing,
        options = <span class="keyword">this</span>.options, relatedData = syncing.relatedData;</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>Inject all appropriate select costraints dealing with the relation
into the <code>knex</code> query builder for the current instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (relatedData) {
        relatedData.selectConstraints(<span class="keyword">this</span>.query, options);
      } <span class="keyword">else</span> {
        columns = options.columns;
        <span class="keyword">if</span> (!_.isArray(columns)) columns = columns ? [columns] : [<span class="string">'*'</span>];
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>Create the deferred object, triggering a <code>fetching</code> event if the model
isn&#39;t an eager load.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">return</span> when(<span class="keyword">function</span>(){
        <span class="keyword">if</span> (!options.isEager) <span class="keyword">return</span> syncing.triggerThen(<span class="string">'fetching'</span>, syncing, columns, options);
      }()).then(<span class="keyword">function</span>() {
        <span class="keyword">return</span> sync.query.select(columns);
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>Issues an <code>insert</code> command on the query - only used by models.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    insert: <span class="keyword">function</span>() {
      <span class="keyword">var</span> syncing = <span class="keyword">this</span>.syncing;
      <span class="keyword">return</span> <span class="keyword">this</span>.query
        .insert(syncing.format(_.extend(Object.create(<span class="literal">null</span>), syncing.attributes)), syncing.idAttribute);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>Issues an <code>update</code> command on the query - only used by models.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    update: <span class="keyword">function</span>(attrs) {
      <span class="keyword">var</span> syncing = <span class="keyword">this</span>.syncing, query = <span class="keyword">this</span>.query;
      <span class="keyword">if</span> (syncing.id != <span class="literal">null</span>) query.where(syncing.idAttribute, syncing.id);
      <span class="keyword">if</span> (query.wheres.length === <span class="number">0</span>) {
        <span class="keyword">return</span> when.reject(<span class="keyword">new</span> Error(<span class="string">'A model cannot be updated without a "where" clause or an idAttribute.'</span>));
      }
      <span class="keyword">return</span> query.update(syncing.format(_.extend(Object.create(<span class="literal">null</span>), attrs)));
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>Issues a <code>delete</code> command on the query.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    del: <span class="keyword">function</span>() {
      <span class="keyword">var</span> query = <span class="keyword">this</span>.query, syncing = <span class="keyword">this</span>.syncing;
      <span class="keyword">if</span> (syncing.id != <span class="literal">null</span>) query.where(syncing.idAttribute, syncing.id);
      <span class="keyword">if</span> (query.wheres.length === <span class="number">0</span>) {
        <span class="keyword">return</span> when.reject(<span class="keyword">new</span> Error(<span class="string">'A model cannot be destroyed without a "where" clause or an idAttribute.'</span>));
      }
      <span class="keyword">return</span> <span class="keyword">this</span>.query.del();
    }
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <h2>Helpers</h2>

            </div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>Specific to many-to-many relationships, these methods are mixed
into the <code>belongsToMany</code> relationships when they are created,
providing helpers for attaching and detaching related models.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Bookshelf.pivotHelpers = {</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>Attach one or more &quot;ids&quot; from a foreign
table to the current. Creates &amp; saves a new model
and attaches the model with a join table entry.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    attach: <span class="keyword">function</span>(ids, options) {
      <span class="keyword">return</span> <span class="keyword">this</span>._handler(<span class="string">'insert'</span>, ids, options);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>Detach related object from their pivot tables.
If a model or id is passed, it attempts to remove the
pivot table based on that foreign key. If a hash is passed,
it attempts to remove the item based on a where clause with
these parameters. If no parameters are specified, we assume we will
detach all related associations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    detach: <span class="keyword">function</span>(ids, options) {
      <span class="keyword">return</span> <span class="keyword">this</span>._handler(<span class="string">'delete'</span>, ids, options);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>Selects any additional columns on the pivot table,
taking a hash of columns which specifies the pivot
column name, and the value the column should take on the
output to the model attributes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    withPivot: <span class="keyword">function</span>(columns) {
      <span class="keyword">this</span>.relatedData.withPivot(columns);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>Helper for handling either the <code>attach</code> or <code>detach</code> call on
the <code>belongsToMany</code> or <code>hasOne</code> / <code>hasMany</code> :through relationship.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _handler: <span class="keyword">function</span>(method, ids, options) {
      <span class="keyword">var</span> pending = [];
      <span class="keyword">if</span> (ids == <span class="keyword">void</span> <span class="number">0</span>) {
        <span class="keyword">if</span> (method === <span class="string">'insert'</span>) <span class="keyword">return</span> when.resolve(<span class="keyword">this</span>);
        <span class="keyword">if</span> (method === <span class="string">'delete'</span>) pending.push(<span class="keyword">this</span>._processPivot(method, <span class="literal">null</span>, options));
      }
      <span class="keyword">if</span> (!_.isArray(ids)) ids = ids ? [ids] : [];
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = ids.length; i &lt; l; i++) {
        pending.push(<span class="keyword">this</span>._processPivot(method, ids[i], options));
      }
      <span class="keyword">var</span> collection = <span class="keyword">this</span>;
      <span class="keyword">return</span> when.all(pending).then(<span class="keyword">function</span>() {
        <span class="keyword">return</span> collection;
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>Handles setting the appropriate constraints and shelling out
to either the <code>insert</code> or <code>delete</code> call for the current model,
returning a promise.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _processPivot: <span class="keyword">function</span>(method, item, options) {
      <span class="keyword">var</span> data = {};
      <span class="keyword">var</span> relatedData = <span class="keyword">this</span>.relatedData;
      data[relatedData.key(<span class="string">'foreignKey'</span>)] = relatedData.parentFk;</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>If the item is an object, it&#39;s either a model
that we&#39;re looking to attach to this model, or
a hash of attributes to set in the relation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (_.isObject(item)) {
        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> Model) {
          data[relatedData.key(<span class="string">'otherKey'</span>)] = item.id;
        } <span class="keyword">else</span> {
          _.extend(data, item);
        }
      } <span class="keyword">else</span> <span class="keyword">if</span> (item) {
        data[relatedData.key(<span class="string">'otherKey'</span>)] = item;
      }
      <span class="keyword">var</span> builder = <span class="keyword">this</span>.builder(relatedData.joinTable());
      <span class="keyword">if</span> (options &amp;&amp; options.transacting) {
        builder.transacting(options.transacting);
      }
      <span class="keyword">if</span> (method === <span class="string">'delete'</span>) <span class="keyword">return</span> builder.where(data).del();
      <span class="keyword">return</span> builder.insert(data);
    }
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>Used internally, the <code>Relation</code> helps in simplifying the relationship building,
centralizing all logic dealing with type &amp; option handling.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> Relation = Bookshelf.Relation = <span class="keyword">function</span>(type, Target, options) {
    <span class="keyword">this</span>.type = type;
    <span class="keyword">if</span> (<span class="keyword">this</span>.target = Target) {
      <span class="keyword">this</span>.targetTableName = _.result(Target.prototype, <span class="string">'tableName'</span>);
      <span class="keyword">this</span>.targetIdAttribute = _.result(Target.prototype, <span class="string">'idAttribute'</span>);
    }
    _.extend(<span class="keyword">this</span>, options);
  };

  Relation.prototype = {</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>Assembles the new model or collection we&#39;re creating an instance of,
gathering any relevant primitives from the parent object,
without keeping any hard references.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    init: <span class="keyword">function</span>(parent) {
      <span class="keyword">this</span>.parentId = parent.id;
      <span class="keyword">this</span>.parentTableName   = _.result(parent, <span class="string">'tableName'</span>);
      <span class="keyword">this</span>.parentIdAttribute = _.result(parent, <span class="string">'idAttribute'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>If the parent object is eager loading, we don&#39;t need the
id attribute, because we&#39;ll just be creating a <code>whereIn</code> from the
previous response anyway.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (!parent._isEager) {
        <span class="keyword">if</span> (<span class="keyword">this</span>.isInverse()) {
          <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'morphTo'</span>) {
            <span class="keyword">this</span>.target = morphCandidate(<span class="keyword">this</span>.candidates, parent.get(<span class="keyword">this</span>.key(<span class="string">'morphKey'</span>)));
          }
          <span class="keyword">this</span>.parentFk = parent.get(<span class="keyword">this</span>.key(<span class="string">'foreignKey'</span>));
        } <span class="keyword">else</span> {
          <span class="keyword">this</span>.parentFk = parent.id;
        }
      }

      <span class="keyword">var</span> target = <span class="keyword">this</span>.target ? <span class="keyword">this</span>.relatedInstance() : {};
          target.relatedData = <span class="keyword">this</span>;

      <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'belongsToMany'</span>) {
        _.extend(target, Bookshelf.pivotHelpers);
      }

      <span class="keyword">return</span> target;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>Initializes a <code>through</code> relation, setting the <code>Target</code> model and <code>options</code>,
which includes any additional keys for the relation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    through: <span class="keyword">function</span>(source, Target, options) {
      <span class="keyword">var</span> type = <span class="keyword">this</span>.type;
      <span class="keyword">if</span> (type !== <span class="string">'hasOne'</span> &amp;&amp; type !== <span class="string">'hasMany'</span> &amp;&amp; type !== <span class="string">'belongsToMany'</span> &amp;&amp; type !== <span class="string">'belongsTo'</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'`through` is only chainable from `hasOne`, `belongsTo`, `hasMany`, or `belongsToMany`'</span>);
      }

      <span class="keyword">this</span>.throughTarget = Target;
      <span class="keyword">this</span>.throughTableName = _.result(Target.prototype, <span class="string">'tableName'</span>);
      <span class="keyword">this</span>.throughIdAttribute = _.result(Target.prototype, <span class="string">'idAttribute'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>Set the parentFk as appropriate now.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'belongsTo'</span>) {
        <span class="keyword">this</span>.parentFk = <span class="keyword">this</span>.parentId;
      }

      _.extend(<span class="keyword">this</span>, options);
      _.extend(source, Bookshelf.pivotHelpers);</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>Set the appropriate foreign key if we&#39;re doing a belongsToMany, for convenience.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'belongsToMany'</span>) {
        <span class="keyword">this</span>.foreignKey = <span class="keyword">this</span>.throughForeignKey;
      }

      <span class="keyword">return</span> source;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>Generates and returns a specified key, for convenience... one of
<code>foreignKey</code>, <code>otherKey</code>, <code>throughForeignKey</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    key: <span class="keyword">function</span>(keyName) {
      <span class="keyword">if</span> (<span class="keyword">this</span>[keyName]) <span class="keyword">return</span> <span class="keyword">this</span>[keyName];
      <span class="keyword">if</span> (keyName === <span class="string">'otherKey'</span>) {
        <span class="keyword">return</span> <span class="keyword">this</span>[keyName] = singularMemo(<span class="keyword">this</span>.targetTableName) + <span class="string">'_'</span> + <span class="keyword">this</span>.targetIdAttribute;
      }
      <span class="keyword">if</span> (keyName === <span class="string">'throughForeignKey'</span>) {
        <span class="keyword">return</span> <span class="keyword">this</span>[keyName] = singularMemo(<span class="keyword">this</span>.joinTable()) + <span class="string">'_'</span> + <span class="keyword">this</span>.throughIdAttribute;
      }
      <span class="keyword">if</span> (keyName === <span class="string">'foreignKey'</span>) {
        <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'morphTo'</span>) <span class="keyword">return</span> <span class="keyword">this</span>[keyName] = <span class="keyword">this</span>.morphName + <span class="string">'_id'</span>;
        <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'belongsTo'</span>) <span class="keyword">return</span> <span class="keyword">this</span>[keyName] = singularMemo(<span class="keyword">this</span>.targetTableName) + <span class="string">'_'</span> + <span class="keyword">this</span>.targetIdAttribute;
        <span class="keyword">if</span> (<span class="keyword">this</span>.isMorph()) <span class="keyword">return</span> <span class="keyword">this</span>[keyName] = <span class="keyword">this</span>.morphName + <span class="string">'_id'</span>;
        <span class="keyword">return</span> <span class="keyword">this</span>[keyName] = singularMemo(<span class="keyword">this</span>.parentTableName) + <span class="string">'_'</span> + <span class="keyword">this</span>.parentIdAttribute;
      }
      <span class="keyword">if</span> (keyName === <span class="string">'morphKey'</span>) <span class="keyword">return</span> <span class="keyword">this</span>[keyName] = <span class="keyword">this</span>.morphName + <span class="string">'_type'</span>;
      <span class="keyword">if</span> (keyName === <span class="string">'morphValue'</span>) <span class="keyword">return</span> <span class="keyword">this</span>[keyName] = <span class="keyword">this</span>.parentTableName || <span class="keyword">this</span>.targetTableName;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>Injects the necessary <code>select</code> constraints into a <code>knex</code> query builder.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    selectConstraints: <span class="keyword">function</span>(knex, options) {
      <span class="keyword">var</span> resp = options.parentResponse;</pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <p>The base select column</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (knex.columns.length === <span class="number">0</span> &amp;&amp; (!options.columns || options.columns.length === <span class="number">0</span>)) {
        knex.columns.push(<span class="keyword">this</span>.isJoined() ? <span class="keyword">this</span>.targetTableName + <span class="string">'.*'</span> : <span class="string">'*'</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> (_.isArray(options.columns) &amp;&amp; options.columns.length &gt; <span class="number">0</span>) {
        push.apply(knex.columns, options.columns);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <p>The <code>belongsToMany</code> and <code>through</code> relations have joins &amp; pivot columns.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>.isJoined()) {
        <span class="keyword">this</span>.joinClauses(knex);
        <span class="keyword">this</span>.joinColumns(knex);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <p>If this is a single relation and we&#39;re not eager loading,
limit the query to a single item.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>.isSingle()) {
        <span class="keyword">if</span> (!resp) knex.limit(<span class="number">1</span>);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <p>Finally, add (and validate) the where conditions, necessary for constraining the relation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">this</span>.whereClauses(knex, resp);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p>Inject &amp; validates necessary <code>through</code> constraints for the current model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    joinColumns: <span class="keyword">function</span>(knex) {
      <span class="keyword">var</span> columns = [];
      <span class="keyword">var</span> joinTable = <span class="keyword">this</span>.joinTable();
      <span class="keyword">if</span> (<span class="keyword">this</span>.isThrough()) columns.push(<span class="keyword">this</span>.throughIdAttribute);
      columns.push(<span class="keyword">this</span>.key(<span class="string">'foreignKey'</span>));
      <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'belongsToMany'</span>) columns.push(<span class="keyword">this</span>.key(<span class="string">'otherKey'</span>));
      push.apply(columns, <span class="keyword">this</span>.pivotColumns);
      push.apply(knex.columns, _.map(columns, <span class="keyword">function</span>(col) {
        <span class="keyword">return</span> joinTable + <span class="string">'.'</span> + col + <span class="string">' as _pivot_'</span> + col;
      }));
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>Generates the join clauses necessary for the current relation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    joinClauses: <span class="keyword">function</span>(knex) {
      <span class="keyword">var</span> joinTable = <span class="keyword">this</span>.joinTable();

      <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'belongsTo'</span> || <span class="keyword">this</span>.type === <span class="string">'belongsToMany'</span>) {

        <span class="keyword">var</span> targetKey = (<span class="keyword">this</span>.type === <span class="string">'belongsTo'</span> ? <span class="keyword">this</span>.key(<span class="string">'foreignKey'</span>) : <span class="keyword">this</span>.key(<span class="string">'otherKey'</span>));

        knex.join(
          joinTable,
          joinTable + <span class="string">'.'</span> + targetKey, <span class="string">'='</span>,
          <span class="keyword">this</span>.targetTableName + <span class="string">'.'</span> + <span class="keyword">this</span>.targetIdAttribute
        );</pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p>A <code>belongsTo</code> -&gt; <code>through</code> is currently the only relation with two joins.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'belongsTo'</span>) {
          knex.join(
            <span class="keyword">this</span>.parentTableName,
            joinTable + <span class="string">'.'</span> + <span class="keyword">this</span>.throughIdAttribute, <span class="string">'='</span>,
            <span class="keyword">this</span>.parentTableName + <span class="string">'.'</span> + <span class="keyword">this</span>.key(<span class="string">'throughForeignKey'</span>)
          );
        }

      } <span class="keyword">else</span> {
        knex.join(
          joinTable,
          joinTable + <span class="string">'.'</span> + <span class="keyword">this</span>.throughIdAttribute, <span class="string">'='</span>,
          <span class="keyword">this</span>.targetTableName + <span class="string">'.'</span> + <span class="keyword">this</span>.key(<span class="string">'throughForeignKey'</span>)
        );
      }
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <p>Check that there isn&#39;t an incorrect foreign key set, vs. the one
passed in when the relation was formed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    whereClauses: <span class="keyword">function</span>(knex, resp) {
      <span class="keyword">var</span> key;

      <span class="keyword">if</span> (<span class="keyword">this</span>.isJoined()) {
        <span class="keyword">var</span> targetTable = <span class="keyword">this</span>.type === <span class="string">'belongsTo'</span> ? <span class="keyword">this</span>.parentTableName : <span class="keyword">this</span>.joinTable();
        key = targetTable + <span class="string">'.'</span> + (<span class="keyword">this</span>.type === <span class="string">'belongsTo'</span> ? <span class="keyword">this</span>.parentIdAttribute : <span class="keyword">this</span>.key(<span class="string">'foreignKey'</span>));
      } <span class="keyword">else</span> {
        key = <span class="keyword">this</span>.isInverse() ? <span class="keyword">this</span>.parentIdAttribute : <span class="keyword">this</span>.key(<span class="string">'foreignKey'</span>);
      }

      knex[resp ? <span class="string">'whereIn'</span> : <span class="string">'where'</span>](key, resp ? <span class="keyword">this</span>.eagerKeys(resp) : <span class="keyword">this</span>.parentFk);

      <span class="keyword">if</span> (<span class="keyword">this</span>.isMorph()) {
        knex.where(<span class="keyword">this</span>.key(<span class="string">'morphKey'</span>), <span class="keyword">this</span>.key(<span class="string">'morphValue'</span>));
      }
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <p>Fetches all <code>eagerKeys</code> from the current relation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    eagerKeys: <span class="keyword">function</span>(resp) {
      <span class="keyword">return</span> _.uniq(_.pluck(resp, <span class="keyword">this</span>.isInverse() ? <span class="keyword">this</span>.key(<span class="string">'foreignKey'</span>) : <span class="keyword">this</span>.parentIdAttribute));
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <p>Generates the appropriate standard join table.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    joinTable: <span class="keyword">function</span>() {
      <span class="keyword">if</span> (<span class="keyword">this</span>.isThrough()) <span class="keyword">return</span> <span class="keyword">this</span>.throughTableName;
      <span class="keyword">return</span> <span class="keyword">this</span>.joinTableName || [
        <span class="keyword">this</span>.parentTableName,
        <span class="keyword">this</span>.targetTableName
      ].sort().join(<span class="string">'_'</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p>Sets the constraints necessary during a <code>model.save</code> call.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    saveConstraints: <span class="keyword">function</span>(model) {
      <span class="keyword">var</span> data = {};
      <span class="keyword">var</span> type = <span class="keyword">this</span>.type;
      <span class="keyword">if</span> (type &amp;&amp; type !== <span class="string">'belongsToMany'</span>) {
        data[<span class="keyword">this</span>.key(<span class="string">'foreignKey'</span>)] = <span class="keyword">this</span>.parentFk;
        <span class="keyword">if</span> (<span class="keyword">this</span>.isMorph()) data[<span class="keyword">this</span>.key(<span class="string">'morphKey'</span>)] = <span class="keyword">this</span>.key(<span class="string">'morphValue'</span>);
      }
      <span class="keyword">return</span> model.set(data);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <p>Creates a new model or collection instance, depending on
the <code>relatedData</code> settings and the models passed in.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    relatedInstance: <span class="keyword">function</span>(models) {
      models || (models = []);

      <span class="keyword">var</span> Target = <span class="keyword">this</span>.target;
      <span class="keyword">if</span> (<span class="keyword">this</span>.isSingle()) {
        <span class="keyword">if</span> (!Target.prototype <span class="keyword">instanceof</span> Model) {
          <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'The `'</span>+<span class="keyword">this</span>.type+<span class="string">'` related object must be a Bookshelf.Model'</span>);
        }
        <span class="keyword">return</span> models[<span class="number">0</span>] || <span class="keyword">new</span> Target();
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <p>Allows us to just use a model, but create a temporary collection for
a many relation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (Target.prototype <span class="keyword">instanceof</span> Model) {
        Target = Bookshelf.Collection.extend({
          model: Target,
          builder: Target.prototype.builder
        });
      }
      <span class="keyword">return</span> <span class="keyword">new</span> Target(models, {parse: <span class="literal">true</span>});
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <p>Creates a new model, used internally in the eager fetch helper methods.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    createModel: <span class="keyword">function</span>(data) {
      <span class="keyword">if</span> (<span class="keyword">this</span>.target.prototype <span class="keyword">instanceof</span> Collection) {
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.target.prototype.model(data, {parse: <span class="literal">true</span>})._reset();
      }
      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.target(data, {parse: <span class="literal">true</span>})._reset();
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-137">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-137">&#182;</a>
              </div>
              <p>Groups the related response according to the type of relationship
we&#39;re handling, for easy attachment to the parent models.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    eagerPair: <span class="keyword">function</span>(relationName, related, models) {</pre></div></div>
            
        </li>
        
        
        <li id="section-138">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-138">&#182;</a>
              </div>
              <p>If this is a <code>through</code> or <code>belongsToMany</code> relation, we need to cleanup &amp; setup the <code>interim</code> model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>.isJoined()) related = <span class="keyword">this</span>.parsePivot(related);

      <span class="keyword">var</span> grouped = _.groupBy(related, <span class="keyword">function</span>(model) {
        <span class="keyword">return</span> <span class="keyword">this</span>.isSingle() ? model.id : (model.pivot ?
          model.pivot.get(<span class="keyword">this</span>.key(<span class="string">'foreignKey'</span>)) : model.get(<span class="keyword">this</span>.key(<span class="string">'foreignKey'</span>)));
      }, <span class="keyword">this</span>);

      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = models.length; i &lt; l; i++) {
        <span class="keyword">var</span> model = models[i];
        <span class="keyword">var</span> groupedKey = <span class="keyword">this</span>.isInverse() ? model.get(<span class="keyword">this</span>.key(<span class="string">'foreignKey'</span>)) : model.id;
        model.relations[relationName] = <span class="keyword">this</span>.relatedInstance(grouped[groupedKey]);
      }
      <span class="keyword">return</span> related;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-139">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-139">&#182;</a>
              </div>
              <p>The <code>models</code> is an array of models returned from the fetch,
after they&#39;re <code>set</code>... parsing out any of the <code>_pivot_</code> items from the
join table and assigning them on the pivot model or object as appropriate.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    parsePivot: <span class="keyword">function</span>(models) {
      <span class="keyword">var</span> Through = <span class="keyword">this</span>.throughTarget;
      <span class="keyword">return</span> _.map(models, <span class="keyword">function</span>(model) {
        <span class="keyword">var</span> data = {}, attrs = model.attributes, through;
        <span class="keyword">if</span> (Through) through = <span class="keyword">new</span> Through();
        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> attrs) {
          <span class="keyword">if</span> (key.indexOf(<span class="string">'_pivot_'</span>) === <span class="number">0</span>) {
            data[key.slice(<span class="number">7</span>)] = attrs[key];
            <span class="keyword">delete</span> attrs[key];
          }
        }
        <span class="keyword">if</span> (!_.isEmpty(data)) {
          model.pivot = through ? through.set(data, {silent: <span class="literal">true</span>}) : <span class="keyword">new</span> Model(data, {
            tableName: <span class="keyword">this</span>.joinTable()
          });
        }
        <span class="keyword">return</span> model;
      }, <span class="keyword">this</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-140">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-140">&#182;</a>
              </div>
              <p>A few predicates to help clarify some of the logic above.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    isThrough: <span class="keyword">function</span>() {
      <span class="keyword">return</span> (<span class="keyword">this</span>.throughTarget != <span class="literal">null</span>);
    },
    isJoined: <span class="keyword">function</span>() {
      <span class="keyword">return</span> (<span class="keyword">this</span>.type === <span class="string">'belongsToMany'</span> || <span class="keyword">this</span>.isThrough());
    },
    isMorph: <span class="keyword">function</span>() {
      <span class="keyword">return</span> (<span class="keyword">this</span>.type === <span class="string">'morphOne'</span> || <span class="keyword">this</span>.type === <span class="string">'morphMany'</span>);
    },
    isSingle: <span class="keyword">function</span>() {
      <span class="keyword">var</span> type = <span class="keyword">this</span>.type;
      <span class="keyword">return</span> (type === <span class="string">'hasOne'</span> || type === <span class="string">'belongsTo'</span> || type === <span class="string">'morphOne'</span> || type === <span class="string">'morphTo'</span>);
    },
    isInverse: <span class="keyword">function</span>() {
      <span class="keyword">return</span> (<span class="keyword">this</span>.type === <span class="string">'belongsTo'</span> || <span class="keyword">this</span>.type === <span class="string">'morphTo'</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-141">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-141">&#182;</a>
              </div>
              <p>Sets the <code>pivotColumns</code> to be retrieved along with the current model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    withPivot: <span class="keyword">function</span>(columns) {
      <span class="keyword">if</span> (!_.isArray(columns)) columns = [columns];
      <span class="keyword">this</span>.pivotColumns || (<span class="keyword">this</span>.pivotColumns = []);
      push.apply(<span class="keyword">this</span>.pivotColumns, columns);
    }
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-142">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-142">&#182;</a>
              </div>
              <h2>Helper functions</h2>

            </div>
            
        </li>
        
        
        <li id="section-143">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-143">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> noop = <span class="keyword">function</span>() {};</pre></div></div>
            
        </li>
        
        
        <li id="section-144">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-144">&#182;</a>
              </div>
              <p>If there are no arguments, return the current object&#39;s
query builder (or create and return a new one). If there are arguments,
call the query builder with the first argument, applying the rest.
If the first argument is an object, assume the keys are query builder
methods, and the values are the arguments for the query.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> query = <span class="keyword">function</span>(obj, args) {
    obj._knex || (obj._knex = obj.builder(_.result(obj, <span class="string">'tableName'</span>)));
    <span class="keyword">if</span> (args.length === <span class="number">0</span>) <span class="keyword">return</span> obj._knex;
    <span class="keyword">var</span> method = args[<span class="number">0</span>];
    <span class="keyword">if</span> (_.isFunction(method)) {
      method.call(obj._knex, obj._knex);
    } <span class="keyword">else</span> <span class="keyword">if</span> (_.isObject(method)) {
      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> method) {
        <span class="keyword">var</span> target = _.isArray(method[key]) ?  method[key] : [method[key]];
        obj._knex[key].apply(obj._knex, target);
      }
    } <span class="keyword">else</span> {
      obj._knex[method].apply(obj._knex, args.slice(<span class="number">1</span>));
    }
    <span class="keyword">return</span> obj;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-145">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-145">&#182;</a>
              </div>
              <p>Simple memoization of the singularize call.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> singularMemo = (<span class="keyword">function</span>() {
    <span class="keyword">var</span> cache = Object.create(<span class="literal">null</span>);
    <span class="keyword">return</span> <span class="keyword">function</span>(arg) {
      <span class="keyword">if</span> (arg <span class="keyword">in</span> cache) {
        <span class="keyword">return</span> cache[arg];
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> cache[arg] = inflection.singularize(arg);
      }
    };
  }());</pre></div></div>
            
        </li>
        
        
        <li id="section-146">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-146">&#182;</a>
              </div>
              <p>Finds the specific <code>morphTo</code> table we should be working with, or throws
an error if none is matched.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> morphCandidate = <span class="keyword">function</span>(candidates, foreignTable) {
    <span class="keyword">var</span> Target = _.find(candidates, <span class="keyword">function</span>(Candidate) {
      <span class="keyword">return</span> (_.result(Candidate.prototype, <span class="string">'tableName'</span>) === foreignTable);
    });
    <span class="keyword">if</span> (!Target) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'The target polymorphic model was not found'</span>);
    }
    <span class="keyword">return</span> Target;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-147">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-147">&#182;</a>
              </div>
              <p>References to the default <code>Knex</code> and <code>Knex.Transaction</code>, overwritten
when a new database connection is created in <code>Initialize</code> below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Bookshelf.Knex = knex;
  Bookshelf.Transaction = knex.Transaction;</pre></div></div>
            
        </li>
        
        
        <li id="section-148">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-148">&#182;</a>
              </div>
              <h2>Bookshelf.Initialize</h2>

            </div>
            
        </li>
        
        
        <li id="section-149">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-149">&#182;</a>
              </div>
              <p>Configure the <code>Bookshelf</code> settings (database adapter, etc.) once,
so it is ready on first model initialization.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Bookshelf.Initialize = <span class="keyword">function</span>(name, options) {
    <span class="keyword">var</span> Target;
    <span class="keyword">if</span> (_.isObject(name)) {
      options = name;
      name = <span class="string">'main'</span>;
    }
    <span class="keyword">if</span> (Bookshelf.Instances[name]) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'A '</span> + name + <span class="string">' instance of Bookshelf already exists'</span>);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-150">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-150">&#182;</a>
              </div>
              <p>If an object with this name already exists in <code>Knex.Instances</code>, we will
use that copy of <code>Knex</code> without trying to re-initialize.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> Builder = (knex[name] || knex.Initialize(name, options));

    <span class="keyword">if</span> (name === <span class="string">'main'</span>) {
      Target = Bookshelf.Instances[<span class="string">'main'</span>] = Bookshelf;
    } <span class="keyword">else</span> {
      Target = Bookshelf.Instances[name] = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-151">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-151">&#182;</a>
              </div>
              <p>Create a new <code>Bookshelf</code> instance for this database connection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      _.extend(Target, _.omit(Bookshelf, <span class="string">'Instances'</span>, <span class="string">'Initialize'</span>, <span class="string">'Knex'</span>, <span class="string">'Transaction'</span>, <span class="string">'VERSION'</span>), {
        Knex: Builder,
        Transaction: Builder.Transaction
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-152">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-152">&#182;</a>
              </div>
              <p>Attach a new builder function that references the correct connection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      _.each([<span class="string">'Model'</span>, <span class="string">'Collection'</span>, <span class="string">'EagerRelation'</span>], <span class="keyword">function</span>(item) {
        Target[item] = Bookshelf[item].extend({
          builder: <span class="keyword">function</span>(table) {
            <span class="keyword">return</span> Builder(table);
          }
        });
      });
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-153">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-153">&#182;</a>
              </div>
              <p>Set the instanceName, so we know what Bookshelf we&#39;re using.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Target.instanceName = name;</pre></div></div>
            
        </li>
        
        
        <li id="section-154">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-154">&#182;</a>
              </div>
              <p>Return the initialized instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">return</span> Target;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-155">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-155">&#182;</a>
              </div>
              <p>Named instances of Bookshelf, presumably with different <code>Knex</code>
options, to initialize different databases.
The main instance being named &quot;main&quot;...</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Bookshelf.Instances = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-156">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-156">&#182;</a>
              </div>
              <p>The main Bookshelf <code>instanceName</code>... incase we&#39;re using Bookshelf
after <code>Knex</code> has been initialized, for consistency.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Bookshelf.instanceName = <span class="string">'main'</span>;

});

})(
  <span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd ? define : <span class="function"><span class="keyword">function</span> <span class="params">(factory)</span> {</span> factory(require, exports); }
);</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
