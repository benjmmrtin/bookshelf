<!DOCTYPE html>

<html>
<head>
  <title>bookshelf.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>bookshelf.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <pre><code>Bookshelf.js 0.2.8

(c) 2013 Tim Griesser
Bookshelf may be freely distributed under the MIT license.
For all details and documentation:
http://bookshelfjs.org</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="keyword">function</span>() {

  <span class="string">"use strict"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2>Initial Setup</h2>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> Bookshelf = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Keep a reference to our own copy of Backbone, in case we want to use
this specific instance elsewhere in the application.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> Backbone = Bookshelf.Backbone = require(<span class="string">'backbone'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Local dependency references.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> _      = require(<span class="string">'underscore'</span>);
  <span class="keyword">var</span> when   = require(<span class="string">'when'</span>);
  <span class="keyword">var</span> Knex   = require(<span class="string">'knex'</span>);
  <span class="keyword">var</span> Inflection = require(<span class="string">'inflection'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Mixin the <code>triggerThen</code> function into all relevant Backbone objects,
so we can have event driven async validations, functions, etc.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  require(<span class="string">'trigger-then'</span>)(Backbone, when);</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Keep in sync with <code>package.json</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Bookshelf.VERSION = <span class="string">'0.2.8'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>We&#39;re using <code>Backbone.Events</code> rather than <code>EventEmitter</code>,
for consistency and portability.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> Events = Bookshelf.Events = Backbone.Events;</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p><code>Bookshelf</code> may be used as a top-level pub-sub bus.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _.extend(Bookshelf, Events);

  <span class="keyword">var</span> push = Array.prototype.push;</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Shared functions which are mixed-in to the
<code>Model</code>, <code>Collection</code>, and <code>EagerRelation</code> prototypes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> Shared = {</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Returns an instance of the query builder.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    builder: <span class="keyword">function</span>(table) {
      <span class="keyword">return</span> Knex(table);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>If there are no arguments, return the current object&#39;s
query builder (or create and return a new one). If there are arguments,
call the query builder with the first argument, applying the rest.
If the first argument is an object, assume the keys are query builder
methods, and the values are the arguments for the query.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    query: <span class="keyword">function</span>() {
      <span class="keyword">this</span>._builder || (<span class="keyword">this</span>._builder = <span class="keyword">this</span>.builder(_.result(<span class="keyword">this</span>, <span class="string">'tableName'</span>)));
      <span class="keyword">var</span> args = _.toArray(arguments);
      <span class="keyword">if</span> (args.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">this</span>._builder;
      <span class="keyword">var</span> method = args[<span class="number">0</span>];
      <span class="keyword">if</span> (_.isFunction(method)) {
        method.call(<span class="keyword">this</span>._builder, <span class="keyword">this</span>._builder);
      } <span class="keyword">else</span> <span class="keyword">if</span> (_.isObject(method)) {
        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> method) {
          <span class="keyword">var</span> target = _.isArray(method[key]) ?  method[key] : [method[key]];
          <span class="keyword">this</span>._builder[key].apply(<span class="keyword">this</span>._builder, target);
        }
      } <span class="keyword">else</span> {
        <span class="keyword">this</span>._builder[method].apply(<span class="keyword">this</span>._builder, args.slice(<span class="number">1</span>));
      }
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Reset the query builder, called internally
each time a query is run.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    resetQuery: <span class="keyword">function</span>() {
      <span class="keyword">delete</span> <span class="keyword">this</span>._builder;
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Eager loads relationships onto an already populated
<code>Model</code> or <code>Collection</code> instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    load: <span class="keyword">function</span>(relations, options) {
      <span class="keyword">var</span> target, data;
      <span class="keyword">if</span> (!_.isArray(relations)) relations = relations ? [relations] : [];
      options = _.extend({}, options, {
        shallow: <span class="literal">true</span>,
        withRelated: relations
      });
      <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Collection) {
        data = <span class="keyword">this</span>.toJSON(options);
      } <span class="keyword">else</span> {
        data = [<span class="keyword">this</span>.toJSON(options)];
      }
      <span class="keyword">var</span> model = <span class="keyword">this</span>;
      <span class="keyword">return</span> <span class="keyword">new</span> EagerRelation(<span class="keyword">this</span>, data)
        .fetch(options)
        .then(<span class="keyword">function</span>() {
          <span class="keyword">return</span> model;
        });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Creates and returns a new <code>Bookshelf.Sync</code> instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    sync: <span class="keyword">function</span>(options) {
      <span class="keyword">return</span> <span class="keyword">new</span> Bookshelf.Sync(<span class="keyword">this</span>, options);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Standard constraints for regular or eager loaded relations.
If the model isn&#39;t an eager load or a collection, it doesn&#39;t need
to be populated with the additional <code>where</code> clause, as that&#39;s already taken
care of during model creation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _constraints: <span class="keyword">function</span>(resp) {
      <span class="keyword">var</span> relatedData = <span class="keyword">this</span>.relatedData;
      <span class="keyword">if</span> (resp) {
        <span class="keyword">this</span>.query(<span class="string">'whereIn'</span>, relatedData.foreignKey, _.uniq(_.pluck(resp, relatedData.parentIdAttr)));
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Collection) {
        <span class="keyword">this</span>.query(<span class="string">'where'</span>, relatedData.foreignKey, <span class="string">'='</span>, relatedData.fkValue);
      }
      <span class="keyword">if</span> (relatedData.type === <span class="string">'morphMany'</span>) <span class="keyword">this</span>.query(<span class="string">'where'</span>, relatedData.morphKey, relatedData.morphValue);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Helper method for adding the constraints needed on a regular or eager loaded
<code>belongsToMany</code> relationship.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _belongsToManyConstraints: <span class="keyword">function</span>(resp) {
      <span class="keyword">var</span>
      relatedData   = <span class="keyword">this</span>.relatedData,
      columns       = relatedData.columns || (relatedData.columns = []),
      builder       = <span class="keyword">this</span>.query(),
      tableName     = _.result(<span class="keyword">this</span>, <span class="string">'tableName'</span>),

      otherKey      = relatedData.otherKey,
      foreignKey    = relatedData.foreignKey,
      pivotColumns  = relatedData.pivotColumns,
      joinTableName = relatedData.joinTableName;

      <span class="keyword">if</span> (builder.columns.length === <span class="number">0</span> &amp;&amp; columns.length === <span class="number">0</span>) {
        columns.push(tableName + <span class="string">'.*'</span>);
      }

      columns.push(
        joinTableName + <span class="string">'.'</span> + otherKey + <span class="string">' as '</span> + <span class="string">'_pivot_'</span> + otherKey,
        joinTableName + <span class="string">'.'</span> + foreignKey + <span class="string">' as '</span> + <span class="string">'_pivot_'</span> + foreignKey
      );

      <span class="keyword">if</span> (pivotColumns) push.apply(columns, pivotColumns);

      builder.join(joinTableName, tableName + <span class="string">'.'</span> + _.result(<span class="keyword">this</span>, <span class="string">'idAttribute'</span>), <span class="string">'='</span>, joinTableName + <span class="string">'.'</span> + foreignKey);

      <span class="keyword">if</span> (resp) {
        builder.whereIn(joinTableName + <span class="string">'.'</span> + otherKey, _.pluck(resp, relatedData.parentIdAttr));
      } <span class="keyword">else</span> {
        builder.where(joinTableName + <span class="string">'.'</span> + otherKey, <span class="string">'='</span>, relatedData.fkValue);
      }
    }

  };</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <h2>Bookshelf.Model</h2>

            </div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>A Bookshelf Model represents an individual row in the database table --
It has a similar implementation to the <code>Backbone.Model</code>
constructor, except that defaults are not set until the
object is persisted, and the collection property is not used.</p>
<p>A unique <code>cid</code> property is also added to each created model, similar to
<code>Backbone</code> models, and is useful checking the identity of two models.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> Model = Bookshelf.Model = <span class="keyword">function</span>(attributes, options) {
    <span class="keyword">var</span> attrs = attributes || {};
    options || (options = {});
    <span class="keyword">this</span>.attributes = Object.create(<span class="literal">null</span>);
    <span class="keyword">this</span>._reset();
    <span class="keyword">this</span>.relations = {};
    <span class="keyword">this</span>.cid = _.uniqueId(<span class="string">'c'</span>);
    <span class="keyword">if</span> (options) {
      _.extend(<span class="keyword">this</span>, _.pick(options, modelProps));
      <span class="keyword">if</span> (options.parse) attrs = <span class="keyword">this</span>.parse(attrs, options) || {};
    }
    <span class="keyword">this</span>.set(attrs, options);
    <span class="keyword">this</span>.initialize.apply(<span class="keyword">this</span>, arguments);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>A list of properties that are omitted from the <code>Backbone.Model.prototype</code>, since we&#39;re not
handling validations, or tracking changes in the same fashion as <code>Backbone</code>, we can drop these
specific methods.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> modelOmitted = [<span class="string">'isValid'</span>, <span class="string">'validationError'</span>, <span class="string">'changedAttributes'</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>List of attributes attached directly from the <code>options</code> passed to the constructor.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> modelProps = [<span class="string">'tableName'</span>, <span class="string">'hasTimestamps'</span>];

  _.extend(Model.prototype, _.omit(Backbone.Model.prototype, modelOmitted), Events, Shared, {</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>The <code>hasOne</code> relation specifies that this table has exactly one of
another type of object, specified by a foreign key in the other table. The foreign key is assumed
to be the singular of this object&#39;s <code>tableName</code> with an <code>_id</code> suffix, but a custom <code>foreignKey</code>
attribute may also be specified.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    hasOne: <span class="keyword">function</span>(Target, foreignKey) {
      <span class="keyword">return</span> <span class="keyword">this</span>._hasOneOrMany(Target, foreignKey, <span class="string">'hasOne'</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>The <code>hasMany</code> relation specifies that this object has one or
more rows in another table which match on this object&#39;s primary key. The foreign key is assumed
to be the singular of this object&#39;s <code>tableName</code> with an <code>_id</code> suffix, but a custom <code>foreignKey</code>
attribute may also be specified.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    hasMany: <span class="keyword">function</span>(Target, foreignKey) {
      <span class="keyword">return</span> <span class="keyword">this</span>._hasOneOrMany(Target, foreignKey, <span class="string">'hasMany'</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>A reverse <code>hasOne</code> relation, the <code>belongsTo</code>, where the specified key in this table
matches the primary <code>idAttribute</code> of another table.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    belongsTo: <span class="keyword">function</span>(Target, otherKey) {
      <span class="keyword">return</span> <span class="keyword">this</span>._relatesTo(Target, {
        type: <span class="string">'belongsTo'</span>,
        foreignKey: Target.prototype.idAttribute,
        otherKey: otherKey || singularMemo(_.result(Target.prototype, <span class="string">'tableName'</span>)) + <span class="string">'_id'</span>
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>A <code>belongsToMany</code> relation is when there are many-to-many relation
between two models, with a joining table. The joinTableName may be replaced with another
object, will serve as the joining model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    belongsToMany: <span class="keyword">function</span>(Target, joinTableName, foreignKey, otherKey) {
      <span class="keyword">return</span> <span class="keyword">this</span>._relatesTo(Target, {
        type: <span class="string">'belongsToMany'</span>,
        otherKey: otherKey     || singularMemo(_.result(<span class="keyword">this</span>, <span class="string">'tableName'</span>)) + <span class="string">'_id'</span>,
        foreignKey: foreignKey || singularMemo(_.result(Target.prototype, <span class="string">'tableName'</span>)) + <span class="string">'_id'</span>,
        joinTableName: joinTableName || [
          _.result(<span class="keyword">this</span>, <span class="string">'tableName'</span>),
          _.result(Target.prototype, <span class="string">'tableName'</span>)
        ].sort().join(<span class="string">'_'</span>)
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>A <code>morphOne</code> relation is a one-to-one polymorphic association from this model
to another model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    morphOne: <span class="keyword">function</span>(Target, name) {
     <span class="keyword">return</span> <span class="keyword">this</span>._morphOneOrMany(Target, name, <span class="string">'morphOne'</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>A <code>morphMany</code> relation is a polymorphic many-to-one relation from this model
to many of another model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    morphMany: <span class="keyword">function</span>(Target, name) {
     <span class="keyword">return</span> <span class="keyword">this</span>._morphOneOrMany(Target, name, <span class="string">'morphMany'</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Defines the opposite end of a <code>morphOne</code> or <code>morphMany</code> relationship, where
the alternate end of the polymorphic model is defined.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    morphTo: <span class="keyword">function</span>(name) {
      <span class="keyword">var</span> foreignTable = <span class="keyword">this</span>.get(name + <span class="string">'_type'</span>);
      <span class="keyword">var</span> foreignKey = <span class="keyword">this</span>.get(name + <span class="string">'_id'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Get the rest of the potential constructors, and filter them based on the foreign
table provided.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> candidates = _.rest(arguments);</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Only allow these to be <code>morphTo</code> fetched if we know the constraints, otherwise
if this is an eager load, we handle it a bit differently.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (!<span class="keyword">this</span>._isEager) {
        <span class="keyword">if</span> (!foreignTable || !foreignKey) {
          <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'The '</span> + name + <span class="string">' constraints (type and id) must be supplied for morphTo'</span>);
        }
        <span class="keyword">var</span> Target = morphCandidate(candidates, foreignTable);
        <span class="keyword">return</span> <span class="keyword">this</span>._relatesTo(Target, {
          type: <span class="string">'morphTo'</span>,
          name: name,
          foreignKey: _.result(Target.prototype, <span class="string">'idAttribute'</span>),
          otherKey: name + <span class="string">'_id'</span>
        });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Return an object we&#39;ll use to put together the potential eager fetched <code>morphTo</code>
objects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">return</span> {
        type: <span class="string">'morphTo'</span>,
        name: name,
        candidates: candidates
      };
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Helper for setting up the <code>hasOne</code> or <code>hasMany</code> relations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _hasOneOrMany: <span class="keyword">function</span>(Target, foreignKey, type) {
      <span class="keyword">return</span> <span class="keyword">this</span>._relatesTo(Target, {
        type: type,
        foreignKey: foreignKey || singularMemo(_.result(<span class="keyword">this</span>, <span class="string">'tableName'</span>)) + <span class="string">'_id'</span>
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Helper for setting up the <code>morphOne</code> or <code>morphMany</code> relations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _morphOneOrMany: <span class="keyword">function</span>(Target, name, type) {
      <span class="keyword">if</span> (!name) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'The polymorphic `name` is required.'</span>);
      <span class="keyword">return</span> <span class="keyword">this</span>._relatesTo(Target, {
        type: type,
        name: name,
        foreignKey: name + <span class="string">'_id'</span>,
        morphKey: name + <span class="string">'_type'</span>,
        morphValue: _.result(<span class="keyword">this</span>, <span class="string">'tableName'</span>)
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Similar to the standard <code>Backbone</code> set method, but without individual
change events, and adding different meaning to <code>changed</code> and <code>previousAttributes</code>
defined as the last &quot;sync&quot;&#39;ed state of the model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    set: <span class="keyword">function</span>(key, val, options) {
      <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">this</span>;
      <span class="keyword">var</span> attr, attrs, changing;</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Handle both <code>&quot;key&quot;, value</code> and <code>{key: value}</code> -style arguments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">'object'</span>) {
        attrs = key;
        options = val;
      } <span class="keyword">else</span> {
        (attrs = {})[key] = val;
      }
      options || (options = {});</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Extract attributes and options.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> hasChanged = <span class="literal">false</span>;
      <span class="keyword">var</span> unset   = options.unset;
      <span class="keyword">var</span> current = <span class="keyword">this</span>.attributes;
      <span class="keyword">var</span> prev    = <span class="keyword">this</span>._previousAttributes;</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Check for changes of <code>id</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>.idAttribute <span class="keyword">in</span> attrs) <span class="keyword">this</span>.id = attrs[<span class="keyword">this</span>.idAttribute];</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>For each <code>set</code> attribute, update or delete the current value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">for</span> (attr <span class="keyword">in</span> attrs) {
        val = attrs[attr];
        <span class="keyword">if</span> (!_.isEqual(prev[attr], val)) {
          <span class="keyword">this</span>.changed[attr] = val;
          <span class="keyword">if</span> (!_.isEqual(current[attr], val)) hasChanged = <span class="literal">true</span>;
        } <span class="keyword">else</span> {
          <span class="keyword">delete</span> <span class="keyword">this</span>.changed[attr];
        }
        unset ? <span class="keyword">delete</span> current[attr] : current[attr] = val;
      }

      <span class="keyword">if</span> (hasChanged &amp;&amp; !options.silent) <span class="keyword">this</span>.trigger(<span class="string">'change'</span>, <span class="keyword">this</span>, options);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Fetch a model based on the currently set attributes,
returning a model to the callback, along with any options.
Returns a deferred promise through the Bookshelf.sync.
If <code>{require: true}</code> is set as an option, the fetch is considered
a failure if the model comes up blank.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    fetch: <span class="keyword">function</span>(options) {
      <span class="keyword">var</span> model = <span class="keyword">this</span>;
      options || (options = {});
      <span class="keyword">return</span> <span class="keyword">this</span>.sync(options)
        .first()
        .then(<span class="keyword">function</span>(resp) {
          <span class="keyword">if</span> (resp &amp;&amp; resp.length &gt; <span class="number">0</span>) {
            model.set(model.parse(resp[<span class="number">0</span>], options), _.extend({silent: <span class="literal">true</span>}, options))._reset();
            <span class="keyword">if</span> (!options.withRelated) <span class="keyword">return</span> resp;
            <span class="keyword">return</span> <span class="keyword">new</span> EagerRelation(model, resp)
              .fetch(options)
              .then(<span class="keyword">function</span>() { <span class="keyword">return</span> resp; });
          }
          <span class="keyword">if</span> (options.require) <span class="keyword">return</span> when.reject(<span class="keyword">new</span> Error(<span class="string">'EmptyResponse'</span>));
        })
        .then(<span class="keyword">function</span>(resp) {
          <span class="keyword">if</span> (resp &amp;&amp; resp.length &gt; <span class="number">0</span>) {
            <span class="keyword">return</span> model.triggerThen(<span class="string">'fetched'</span>, model, resp, options).then(<span class="keyword">function</span>() {
              <span class="keyword">return</span> model;
            });
          }
          <span class="keyword">return</span> <span class="literal">null</span>;
        });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Sets and saves the hash of model attributes, triggering
a &quot;creating&quot; or &quot;updating&quot; event on the model, as well as a &quot;saving&quot; event,
to bind listeners for any necessary validation, logging, etc.
If an error is thrown during these events, the model will not be saved.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    save: <span class="keyword">function</span>(key, val, options) {
      <span class="keyword">var</span> attrs;</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Handle both <code>&quot;key&quot;, value</code> and <code>{key: value}</code> -style arguments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (key == <span class="literal">null</span> || <span class="keyword">typeof</span> key === <span class="string">"object"</span>) {
        attrs = key || {};
        options = val || {};
      } <span class="keyword">else</span> {
        options || (options = {});
        (attrs = {})[key] = val;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>If the model has timestamp columns,
set them as attributes on the model, even
if the &quot;partial&quot; option is specified.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>.hasTimestamps) {
        _.extend(attrs, <span class="keyword">this</span>.timestamp(options));
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Determine whether the model is new, based on whether the model has an <code>idAttribute</code> or not.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> method = options.method || (options.method = <span class="keyword">this</span>.isNew(options) ? <span class="string">'insert'</span> : <span class="string">'update'</span>);
      <span class="keyword">var</span> vals = attrs;</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>If the object is being created, we merge any defaults here
rather than during object creation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (method === <span class="string">'insert'</span> || options.defaults) {
        <span class="keyword">var</span> defaults = _.result(<span class="keyword">this</span>, <span class="string">'defaults'</span>);
        <span class="keyword">if</span> (defaults) {
          vals = _.extend({}, defaults, <span class="keyword">this</span>.attributes, vals);
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Set the attributes on the model, and maintain a reference to use below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> model  = <span class="keyword">this</span>.set(vals, {silent: <span class="literal">true</span>});
      <span class="keyword">var</span> sync   = <span class="keyword">this</span>.sync(options);

      <span class="keyword">return</span> when.all([
        model.triggerThen((method === <span class="string">'insert'</span> ? <span class="string">'creating'</span> : <span class="string">'updating'</span>), model, attrs, options),
        model.triggerThen(<span class="string">'saving'</span>, model, attrs, options)
      ])
      .then(<span class="keyword">function</span>() {
        <span class="keyword">var</span> attrs = model.attributes;
        <span class="keyword">return</span> sync[method](attrs, options);
      })
      .then(<span class="keyword">function</span>(resp) {</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>After a successful database save, the id is updated if the model was created</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (method === <span class="string">'insert'</span> &amp;&amp; resp) {
          model.attributes[model.idAttribute] = model[model.idAttribute] = resp[<span class="number">0</span>];
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>In case we need to reference the <code>previousAttributes</code> for the model
in the following event handlers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        options.previousAttributes = model._previousAttributes;

        model._reset();

        <span class="keyword">return</span> when.all([
          model.triggerThen((method === <span class="string">'insert'</span> ? <span class="string">'created'</span> : <span class="string">'updated'</span>), model, resp, options),
          model.triggerThen(<span class="string">'saved'</span>, model, resp, options)
        ]);

      }).then(<span class="keyword">function</span>() {
        <span class="keyword">return</span> model;
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Destroy a model, calling a &quot;delete&quot; based on its <code>idAttribute</code>.
A &quot;destroying&quot; and &quot;destroyed&quot; are triggered on the model before
and after the model is destroyed, respectively. If an error is thrown
during the &quot;destroying&quot; event, the model will not be destroyed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    destroy: <span class="keyword">function</span>(options) {
      options || (options = {});
      <span class="keyword">var</span> model = <span class="keyword">this</span>;
      <span class="keyword">return</span> model.triggerThen(<span class="string">'destroying'</span>, model, options)
      .then(<span class="keyword">function</span>() { <span class="keyword">return</span> model.sync(options).del(options); })
      .then(<span class="keyword">function</span>(resp) {
        model.clear();
        <span class="keyword">return</span> model.triggerThen(<span class="string">'destroyed'</span>, model, resp, options).then(<span class="keyword">function</span>() {
          <span class="keyword">return</span> model._reset();
        });
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p><strong>format</strong> converts a model into the values that should be saved into
the database table. The default implementation is just to pass the response along.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    format: <span class="keyword">function</span>(attrs, options) {
      <span class="keyword">return</span> attrs;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Returns an object containing a shallow copy of the model attributes,
along with the <code>toJSON</code> value of any relations,
unless <code>{shallow: true}</code> is passed in the <code>options</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    toJSON: <span class="keyword">function</span>(options) {
      <span class="keyword">var</span> attrs = _.extend({}, <span class="keyword">this</span>.attributes);
      <span class="keyword">if</span> (options &amp;&amp; options.shallow) <span class="keyword">return</span> attrs;
      <span class="keyword">var</span> relations = <span class="keyword">this</span>.relations;
      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> relations) {
        <span class="keyword">var</span> relation = relations[key];
        attrs[key] = relation.toJSON ? relation.toJSON() : relation;
      }
      <span class="keyword">return</span> attrs;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>Sets the timestamps before saving the model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    timestamp: <span class="keyword">function</span>(options) {
      <span class="keyword">var</span> d = <span class="keyword">new</span> Date();
      <span class="keyword">var</span> keys = (_.isArray(<span class="keyword">this</span>.hasTimestamps) ? <span class="keyword">this</span>.hasTimestamps : [<span class="string">'created_at'</span>, <span class="string">'updated_at'</span>]);
      <span class="keyword">var</span> vals = {};
      vals[keys[<span class="number">1</span>]] = d;
      <span class="keyword">if</span> (<span class="keyword">this</span>.isNew(options) &amp;&amp; (!options || options.method !== <span class="string">'update'</span>)) vals[keys[<span class="number">0</span>]] = d;
      <span class="keyword">return</span> vals;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Create a new model with identical attributes to this one,
including any relations on the current model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    clone: <span class="keyword">function</span>() {
      <span class="keyword">var</span> model = <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="keyword">this</span>.attributes);
      <span class="keyword">var</span> relations = <span class="keyword">this</span>.relations;
      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> relations) {
        model.relations[key] = relations[key].clone();
      }
      model._previousAttributes = _.clone(<span class="keyword">this</span>._previousAttributes);
      model.changed = _.clone(<span class="keyword">this</span>.changed);
      <span class="keyword">return</span> model;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>Creates a new relation, from the current object to the
&#39;target&#39; object (collection or model), passing a hash of
options which can include the <code>type</code> of relation.
The <code>hasOne</code> and <code>belongsTo</code> relations may only &quot;target&quot; a <code>Model</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _relatesTo: <span class="keyword">function</span>(Target, options) {
      <span class="keyword">var</span> target, data;
      <span class="keyword">var</span> type = options.type;
      <span class="keyword">var</span> multi  = (type === <span class="string">'hasMany'</span> || type === <span class="string">'belongsToMany'</span> || type === <span class="string">'morphMany'</span>);
      <span class="keyword">var</span> single = (type === <span class="string">'belongsTo'</span> || type === <span class="string">'morphOne'</span> || type === <span class="string">'morphTo'</span>);

      <span class="keyword">if</span> (!multi) {
        data = {};
        <span class="keyword">if</span> (!Target.prototype <span class="keyword">instanceof</span> Model) {
          <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'The `'</span>+type+<span class="string">'` related object must be a Bookshelf.Model'</span>);
        }
      } <span class="keyword">else</span> <span class="keyword">if</span> (Target.prototype <span class="keyword">instanceof</span> Model) {
        Target = Bookshelf.Collection.extend({
          model: Target,
          builder: Target.prototype.builder
        });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>If we&#39;re handling an eager loaded related model,
keep a reference to the original constructor to assemble
the correct object once the eager matching is finished.
Otherwise, just grab the <code>foreignKey</code> value for building the query.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (<span class="keyword">this</span>._isEager) {
        options.eager = {};
        <span class="keyword">if</span> (multi) {
          options.eager.ModelCtor = Target.prototype.model;
          options.eager.CollectionCtor = Target;
        } <span class="keyword">else</span> {
          options.eager.ModelCtor = Target;
        }
        options.parentIdAttr = (single ? options.otherKey : _.result(<span class="keyword">this</span>, <span class="string">'idAttribute'</span>));
      } <span class="keyword">else</span> {
        <span class="keyword">if</span> (type === <span class="string">'belongsTo'</span> || type === <span class="string">'morphTo'</span>) {
          options.fkValue = <span class="keyword">this</span>.get(options.otherKey);
        } <span class="keyword">else</span> {
          options.fkValue = <span class="keyword">this</span>.id;
        }
        <span class="keyword">if</span> (!multi) {
          data[options.foreignKey] = options.fkValue;
          <span class="keyword">if</span> (options.morphKey) data[options.morphKey] = options.morphValue;
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Create a new instance of the <code>Model</code> or <code>Collection</code>, and set the
<code>relatedData</code> options as a property on the instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      target = <span class="keyword">new</span> Target(data);
      target.relatedData = options;</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Extend the relation with relation-specific methods.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (type === <span class="string">'belongsToMany'</span>) {
        _.extend(target, Bookshelf.pivotHelpers);
      }

      <span class="keyword">return</span> target;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Returns the related item, or creates a new
related item by creating a new model or collection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    related: <span class="keyword">function</span>(name) {
      <span class="keyword">return</span> <span class="keyword">this</span>.relations[name] || (<span class="keyword">this</span>[name] ? <span class="keyword">this</span>.relations[name] = <span class="keyword">this</span>[name]() : <span class="keyword">void</span> <span class="number">0</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>Called after a <code>sync</code> action (save, fetch, delete) -
resets the <code>_previousAttributes</code> and <code>changed</code> hash for the model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _reset: <span class="keyword">function</span>() {
      <span class="keyword">this</span>._previousAttributes = extendNull(<span class="keyword">this</span>.attributes);
      <span class="keyword">this</span>.changed = extendNull();
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>Validation can be complicated, and is better handled
on its own and not mixed in with database logic.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _validate: <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="literal">true</span>;
    }

  });</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <h2>Bookshelf.Collection</h2>

            </div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>A Bookshelf Collection contains a number of database rows, represented by
models, so they can be easily sorted, serialized, and manipulated.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> Collection = Bookshelf.Collection = <span class="keyword">function</span>(models, options) {
    <span class="keyword">if</span> (options) _.extend(<span class="keyword">this</span>, _.pick(options, collectionProps));
    <span class="keyword">var</span> model = <span class="keyword">this</span>.model;
    <span class="keyword">if</span> (!_.isEqual(model, Model) &amp;&amp; !(model.prototype <span class="keyword">instanceof</span> Model)) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Only Bookshelf Model constructors are allowed as the Collection#model attribute.'</span>);
    }
    <span class="keyword">this</span>._reset();
    <span class="keyword">this</span>.initialize.apply(<span class="keyword">this</span>, arguments);
    <span class="keyword">if</span> (models) <span class="keyword">this</span>.reset(models, _.extend({silent: <span class="literal">true</span>}, options));
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>List of attributes attached directly from the constructor&#39;s options object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> collectionProps = [<span class="string">'model'</span>, <span class="string">'comparator'</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>Extend the Collection&#39;s prototype with the base methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _.extend(Collection.prototype, _.omit(Backbone.Collection.prototype, <span class="string">'model'</span>), Events, Shared, {

    model: Model,</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>Fetch the models for this collection, resetting the models for the query
when they arrive.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    fetch: <span class="keyword">function</span>(options) {
      <span class="keyword">var</span> collection = <span class="keyword">this</span>;
      options || (options = {});
      <span class="keyword">return</span> <span class="keyword">this</span>.sync(options)
        .select()
        .then(<span class="keyword">function</span>(resp) {
          <span class="keyword">if</span> (resp &amp;&amp; resp.length &gt; <span class="number">0</span>) {
            collection.reset(resp, {silent: <span class="literal">true</span>, parse: <span class="literal">true</span>}).each(<span class="keyword">function</span>(m) { m._reset(); });
          } <span class="keyword">else</span> {
            collection.reset([], {silent: <span class="literal">true</span>});
            <span class="keyword">return</span> [];
          }
          <span class="keyword">if</span> (!options.withRelated) <span class="keyword">return</span> resp;
          <span class="keyword">return</span> <span class="keyword">new</span> EagerRelation(collection, resp)
            .fetch(options)
            .then(<span class="keyword">function</span>() { <span class="keyword">return</span> resp; });
        })
        .then(<span class="keyword">function</span>(resp) {
          <span class="keyword">return</span> collection.triggerThen(<span class="string">'fetched'</span>, collection, resp, options).then(<span class="keyword">function</span>() {
            <span class="keyword">return</span> collection;
          });
        });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>Shortcut for creating a new model, saving, and adding to the collection.
Returns a promise which will resolve with the model added to the collection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    create: <span class="keyword">function</span>(model, options) {
      options || (options = {});
      model = <span class="keyword">this</span>._prepareModel(model, options);
      <span class="keyword">var</span> collection = <span class="keyword">this</span>;
      <span class="keyword">return</span> model.save(<span class="literal">null</span>, options).then(<span class="keyword">function</span>() {
        collection.add(model, options);
        <span class="keyword">return</span> model;
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>The <code>tableName</code> on the associated Model, used in relation building.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    tableName: <span class="keyword">function</span>() {
      <span class="keyword">return</span> _.result(<span class="keyword">this</span>.model.prototype, <span class="string">'tableName'</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>The <code>idAttribute</code> on the associated Model, used in relation building.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    idAttribute: <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.model.prototype.idAttribute;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>Prepare a model or hash of attributes to be added to this collection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _prepareModel: <span class="keyword">function</span>(attrs, options) {
      <span class="keyword">if</span> (attrs <span class="keyword">instanceof</span> Model) <span class="keyword">return</span> attrs;
      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.model(attrs, options);
    }

  });</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <h2>Bookshelf.EagerRelation</h2>

            </div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>An <code>EagerRelation</code> object temporarily stores the models from an eager load,
and handles matching eager loaded objects with their parent(s). The <code>tempModel</code>
is only used to retrieve the value of the relation method, to know the constrains
for the eager query.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> EagerRelation = Bookshelf.EagerRelation = <span class="keyword">function</span>(parent, parentResponse, options) {
    options || (options = {});</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>Convert a <code>Model</code> or <code>Collection</code> to a <code>RelatedModel</code> instance for consistency when
fetching &amp; pairing the nested relation objects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> Model) {
      <span class="keyword">this</span>.parent = <span class="keyword">new</span> RelatedModels([parent]);
    } <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> Collection) {
      <span class="keyword">this</span>.parent = <span class="keyword">new</span> RelatedModels(parent.models);
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>.parent = parent;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>Set the appropriate target for getting the eager relation data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">this</span>.target = options.tempModel || (parent <span class="keyword">instanceof</span> Collection ? <span class="keyword">new</span> parent.model() : parent);
    <span class="keyword">this</span>.parentResponse = parentResponse;
    _.bindAll(<span class="keyword">this</span>, <span class="string">'pushModels'</span>, <span class="string">'eagerFetch'</span>);
  };

  _.extend(EagerRelation.prototype, Shared, {</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>This helper function is used internally to determine which relations
are necessary for fetching based on the <code>model.load</code> or <code>withRelated</code> option.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    fetch: <span class="keyword">function</span>(options) {
      <span class="keyword">var</span> key, relatedObj, name, related, relation;
      <span class="keyword">var</span> target      = <span class="keyword">this</span>.target;
      <span class="keyword">var</span> handled     = <span class="keyword">this</span>.handled = {};
      <span class="keyword">var</span> withRelated = <span class="keyword">this</span>.prepWithRelated(options.withRelated);
      <span class="keyword">var</span> subRelated  = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>Eager load each of the <code>withRelated</code> relation item, splitting on &#39;.&#39;
which indicates a nested eager load.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">for</span> (key <span class="keyword">in</span> withRelated) {

        related = key.split(<span class="string">'.'</span>);
        name    = related[<span class="number">0</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Add additional eager items to an array, to load at the next level in the query.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (related.length &gt; <span class="number">1</span>) {
          subRelated[name] || (subRelated[name] = []);
          relatedObj = {};
          relatedObj[related.slice(<span class="number">1</span>).join(<span class="string">'.'</span>)] = withRelated[key];
          subRelated[name].push(relatedObj);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>Only allow one of a certain nested type per-level.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (handled[name]) <span class="keyword">continue</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>Internal flag to determine whether to set the ctor(s) on the relatedData hash.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        target._isEager = <span class="literal">true</span>;
        relation = target[name]();
        <span class="keyword">delete</span> target._isEager;

        <span class="keyword">if</span> (!relation) <span class="keyword">throw</span> <span class="keyword">new</span> Error(name + <span class="string">' is not defined on the model.'</span>);

        handled[name] = relation;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>Fetch all eager loaded models, loading them onto
an array of pending deferred objects, which will handle
all necessary pairing with parent objects, etc.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> pendingDeferred = [];
      <span class="keyword">for</span> (name <span class="keyword">in</span> handled) {
        pendingDeferred.push(<span class="keyword">this</span>.eagerFetch(name, handled[name], withRelated[name], _.extend({}, options, {
          isEager: <span class="literal">true</span>,
          withRelated: subRelated[name]
        })));
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>Return a deferred handler for all of the nested object sync
returning the original response when these syncs &amp; pairings are complete.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> eagerHandler = <span class="keyword">this</span>;
      <span class="keyword">return</span> when.all(pendingDeferred).then(<span class="keyword">function</span>() {
        <span class="keyword">return</span> eagerHandler.parentResponse;
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>Prep the <code>withRelated</code> object, to normalize into an object where each
has a function that is called when running the query.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    prepWithRelated: <span class="keyword">function</span>(withRelated) {
      <span class="keyword">if</span> (!_.isArray(withRelated)) withRelated = withRelated ? [withRelated] : [];
      <span class="keyword">var</span> withRelatedObj = {};
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = withRelated.length; i &lt; l; i++) {
        <span class="keyword">if</span> (_.isObject(withRelated[i])) {
          _.extend(withRelatedObj, withRelated[i]);
          <span class="keyword">continue</span>;
        }
        withRelatedObj[withRelated[i]] = <span class="literal">null</span>;
      }
      <span class="keyword">return</span> withRelatedObj;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>Handles an eager loaded fetch, passing the name of the item we&#39;re fetching for,
and any options needed for the current fetch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    eagerFetch: <span class="keyword">function</span>(name, handled, beforeFn, options) {
      <span class="keyword">if</span> (handled.type === <span class="string">'morphTo'</span>) {
        <span class="keyword">return</span> <span class="keyword">this</span>.morphToFetch(name, handled, options);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>Call the function, if one exists, to constrain the eager loaded query.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (beforeFn) beforeFn.call(handled, handled.query());

      <span class="keyword">var</span> _<span class="keyword">this</span> = <span class="keyword">this</span>;
      <span class="keyword">return</span> handled
        .sync(_.extend({}, options, {parentResponse: <span class="keyword">this</span>.parentResponse}))
        .select()
        .then(<span class="keyword">function</span>(resp) {
          <span class="keyword">var</span> relatedModels = _<span class="keyword">this</span>.pushModels(name, handled, resp);</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>If there is a response, fetch additional nested eager relations, if any.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="keyword">if</span> (resp.length &gt; <span class="number">0</span> &amp;&amp; options.withRelated) {
            <span class="keyword">return</span> <span class="keyword">new</span> EagerRelation(relatedModels, resp, {
              tempModel: <span class="keyword">new</span> handled.relatedData.eager.ModelCtor()
            }).fetch(options).then(<span class="keyword">function</span>() {
              <span class="keyword">return</span> resp;
            });
          }
          <span class="keyword">return</span> resp;
        });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>Special handler for the eager loaded morph-to relations, this handles
the fact that there are several potential models that we need to be fetching against.
pairing them up onto a single response for the eager loading.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    morphToFetch: <span class="keyword">function</span>(name, settings, options) {
      <span class="keyword">var</span> pending = [], group;
      <span class="keyword">var</span> groups = <span class="keyword">this</span>.parent.groupBy(<span class="keyword">function</span>(m) {
        <span class="keyword">return</span> m.get(name + <span class="string">'_type'</span>);
      });
      <span class="keyword">for</span> (group <span class="keyword">in</span> groups) {
        <span class="keyword">var</span> Target = morphCandidate(settings.candidates, group);
        <span class="keyword">var</span> target = <span class="keyword">new</span> Target();
        pending.push(target
          .query(<span class="string">'whereIn'</span>, _.result(target, <span class="string">'idAttribute'</span>), _.uniq(_.invoke(groups[group], <span class="string">'get'</span>, name + <span class="string">'_id'</span>)))
          .sync(options)
          .select()
          .then(<span class="keyword">this</span>.morphToHandler(name, settings, Target)));
      }
      <span class="keyword">return</span> when.all(pending).then(<span class="keyword">function</span>(resps) {
        <span class="keyword">return</span> _.flatten(resps);
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>Handler for the individual <code>morphTo</code> fetches,
attaching any of the related models onto the parent objects,
stopping at this level of the eager relation loading.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    morphToHandler: <span class="keyword">function</span>(name, settings, Target) {
      <span class="keyword">var</span> that = <span class="keyword">this</span>;
      <span class="keyword">return</span> <span class="keyword">function</span>(resp) {
        that.pushModels(name, {
          relatedData: {
            type: <span class="string">'morphTo'</span>,
            foreignKey: Target.prototype.idAttribute,
            otherKey: name + <span class="string">'_id'</span>,
            morphKey: name + <span class="string">'_type'</span>,
            morphValue: _.result(Target.prototype, <span class="string">'tableName'</span>),
            eager: {
              ModelCtor: Target
            }
          }
        }, resp);
      };
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>Pushes each of the incoming models onto a new <code>RelatedModels</code> object, which is used to
correcly pair additional nested relations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    pushModels: <span class="keyword">function</span>(name, handled, resp) {
      <span class="keyword">var</span> parent      = <span class="keyword">this</span>.parent;
      <span class="keyword">var</span> related     = <span class="keyword">new</span> RelatedModels([]);
      <span class="keyword">var</span> relatedData = handled.relatedData;
      <span class="keyword">var</span> type        = relatedData.type;
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = resp.length; i &lt; l; i++) {
        related.push(<span class="keyword">new</span> relatedData.eager.ModelCtor(resp[i], {parse: <span class="literal">true</span>})._reset());
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>Attach the appropriate related items onto the parent model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">for</span> (i = <span class="number">0</span>, l = parent.models.length; i &lt; l; i++) {
        <span class="keyword">var</span> model = parent.models[i];
        <span class="keyword">if</span> (type === <span class="string">'morphTo'</span> &amp;&amp; model.get(relatedData.morphKey) !== relatedData.morphValue) <span class="keyword">continue</span>;
        <span class="keyword">var</span> id = (type === <span class="string">'belongsTo'</span> || type === <span class="string">'morphTo'</span> ? model.get(relatedData.otherKey) : model.id);
        model.relations[name] = <span class="keyword">this</span>._eagerRelated(type, relatedData, related, id);
      }
      <span class="keyword">return</span> related;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>Handles the &quot;eager related&quot; relationship matching.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _eagerRelated: <span class="keyword">function</span>(type, relatedData, models, id) {
      <span class="keyword">var</span> where = {};
      <span class="keyword">if</span> (type === <span class="string">'hasOne'</span> || type === <span class="string">'belongsTo'</span> || type === <span class="string">'morphOne'</span> || type === <span class="string">'morphTo'</span>) {
        where[relatedData.foreignKey] = id;
        <span class="keyword">return</span> models.findWhere(where) || <span class="keyword">new</span> relatedData.eager.ModelCtor();
      } <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'hasMany'</span> || type === <span class="string">'morphMany'</span>) {
        where[relatedData.foreignKey] = id;
        <span class="keyword">return</span> <span class="keyword">new</span> relatedData.eager.CollectionCtor(models.where(where), {parse: <span class="literal">true</span>});
      } <span class="keyword">else</span> {
        where[<span class="string">'_pivot_'</span> + relatedData.otherKey] = id;
        <span class="keyword">return</span> <span class="keyword">new</span> relatedData.eager.CollectionCtor(models.where(where), {parse: <span class="literal">true</span>});
      }
    }

  });</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>Temporary helper object for handling the response of an <code>EagerRelation</code> load.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> RelatedModels = <span class="keyword">function</span>(models) {
    <span class="keyword">this</span>.models = models;
    <span class="keyword">this</span>.length = <span class="keyword">this</span>.models.length;
  };
  _.extend(RelatedModels.prototype, _.pick(Collection.prototype, <span class="string">'at'</span>, <span class="string">'find'</span>, <span class="string">'where'</span>, <span class="string">'filter'</span>, <span class="string">'findWhere'</span>, <span class="string">'groupBy'</span>), {</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>Pushes a model onto the <code>RelatedModels</code> object, updates the length of the models array, and returns the added model.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    push: <span class="keyword">function</span>(model) {
      <span class="keyword">this</span>.length = <span class="keyword">this</span>.models.push(model);
      <span class="keyword">return</span> model;
    }

  });</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>Set up inheritance for the model and collection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Model.extend = Collection.extend = EagerRelation.extend = Bookshelf.Backbone.Model.extend;</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>The <code>forge</code> function properly instantiates a new Model or Collection
without needing the &quot;new&quot; operator... to make object creation cleaner
and more chainable.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Model.forge = Collection.forge = <span class="keyword">function</span>() {
    <span class="keyword">var</span> inst = Object.create(<span class="keyword">this</span>.prototype);
    <span class="keyword">var</span> obj = <span class="keyword">this</span>.apply(inst, arguments);
    <span class="keyword">return</span> (Object(obj) === obj ? obj : inst);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <h2>Bookshelf.Sync</h2>

            </div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>Sync is the dispatcher for any database queries,
taking the &quot;syncing&quot; <code>model</code> or <code>collection</code> being queried, along with
a hash of options that are used in the various query methods.
If the <code>transacting</code> option is set, the query is assumed to be
part of a transaction, and this information is passed along to <code>Knex</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> Sync = Bookshelf.Sync = <span class="keyword">function</span>(syncing, options) {
    options || (options = {});
    <span class="keyword">this</span>.syncing = syncing;
    <span class="keyword">this</span>.options = options;
    <span class="keyword">this</span>.query   = syncing.query();
    <span class="keyword">if</span> (options.transacting) <span class="keyword">this</span>.query.transacting(options.transacting);
  };

  _.extend(Sync.prototype, {</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>Select the first item from the database - only used by models.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    first: <span class="keyword">function</span>() {
      <span class="keyword">var</span> syncing = <span class="keyword">this</span>.syncing;
      <span class="keyword">this</span>.query.where(syncing.format(extendNull(syncing.attributes))).limit(<span class="number">1</span>);
      <span class="keyword">return</span> <span class="keyword">this</span>.select();
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>Runs a <code>select</code> query on the database, adding any necessary relational
constraints, resetting the query when complete. If there are results and
eager loaded relations, those are fetched and returned on the model before
the promise is resolved. Any <code>success</code> handler passed in the
options will be called - used by both models &amp; collections.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    select: <span class="keyword">function</span>() {
      <span class="keyword">var</span> syncing     = <span class="keyword">this</span>.syncing;
      <span class="keyword">var</span> options     = <span class="keyword">this</span>.options;
      <span class="keyword">var</span> columns     = options.columns;
      <span class="keyword">var</span> relatedData = syncing.relatedData;</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>Check that the constraints are set properly if this model is set as a relation to another.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (relatedData) {
        <span class="keyword">if</span> (relatedData.fkValue == <span class="literal">null</span> &amp;&amp; !options.parentResponse) {
          <span class="keyword">return</span> when.reject(<span class="keyword">new</span> Error(<span class="string">"The "</span> + relatedData.otherKey + <span class="string">" must be specified."</span>));
        }
        <span class="keyword">if</span> (relatedData.type !== <span class="string">'belongsToMany'</span>) {
          syncing._constraints(options.parentResponse);
        } <span class="keyword">else</span> {
          syncing._belongsToManyConstraints(options.parentResponse);
        }
      }

      <span class="keyword">if</span> (!_.isArray(columns)) columns = columns ? [columns] : [<span class="string">'*'</span>];

      <span class="keyword">if</span> (relatedData &amp;&amp; relatedData.columns) {
        columns = relatedData.columns;
      }

      <span class="keyword">var</span> sync = <span class="keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>Create the deferred object, triggering a <code>fetching</code> event if the model
isn&#39;t an eager load.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">return</span> when(<span class="keyword">function</span>(){
        <span class="keyword">if</span> (!options.isEager) <span class="keyword">return</span> syncing.triggerThen(<span class="string">'fetching'</span>, syncing, columns, options);
      }()).then(<span class="keyword">function</span>() {
        syncing.resetQuery();
        <span class="keyword">return</span> sync.query.select(columns);
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>Issues an <code>insert</code> command on the query - only used by models.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    insert: <span class="keyword">function</span>(attrs) {
      <span class="keyword">var</span> syncing = <span class="keyword">this</span>.syncing.resetQuery();
      <span class="keyword">return</span> <span class="keyword">this</span>.query
        .idAttribute(syncing.idAttribute)
        .insert(syncing.format(extendNull(attrs)));
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>Issues an <code>update</code> command on the query - only used by models.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    update: <span class="keyword">function</span>(attrs, options) {
      <span class="keyword">var</span> query = <span class="keyword">this</span>.query, syncing = <span class="keyword">this</span>.syncing.resetQuery();
      <span class="keyword">if</span> (syncing.id != <span class="literal">null</span>) {
        query.where(syncing.idAttribute, syncing.id);
      }
      <span class="keyword">if</span> (query.wheres.length === <span class="number">0</span>) {
        <span class="keyword">return</span> when.reject(<span class="keyword">new</span> Error(<span class="string">'A model cannot be updated without a "where" clause or an idAttribute.'</span>));
      }
      <span class="keyword">return</span> query.update(syncing.format(extendNull(attrs)));
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>Issues a <code>delete</code> command on the query.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    del: <span class="keyword">function</span>() {
      <span class="keyword">var</span> query = <span class="keyword">this</span>.query, syncing = <span class="keyword">this</span>.syncing.resetQuery();
      <span class="keyword">if</span> (syncing.id != <span class="literal">null</span>) {
        query.where(syncing.idAttribute, syncing.id);
      }
      <span class="keyword">if</span> (query.wheres.length === <span class="number">0</span>) {
        <span class="keyword">return</span> when.reject(<span class="keyword">new</span> Error(<span class="string">'A model cannot be destroyed without a "where" clause or an idAttribute.'</span>));
      }
      <span class="keyword">return</span> <span class="keyword">this</span>.query.del();
    }
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <h2>Helpers</h2>

            </div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>Specific to many-to-many relationships, these methods are mixed
into the <code>belongsToMany</code> relationships when they are created,
providing helpers for attaching and detaching related models.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Bookshelf.pivotHelpers = {</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>Attach one or more &quot;ids&quot; from a foreign
table to the current. Creates &amp; saves a new model
and attaches the model with a join table entry.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    attach: <span class="keyword">function</span>(ids, options) {
      <span class="keyword">return</span> <span class="keyword">this</span>._handler(<span class="string">'insert'</span>, ids, options);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>Detach related object from their pivot tables.
If a model or id is passed, it attempts to remove the
pivot table based on that foreign key. If a hash is passed,
it attempts to remove the item based on a where clause with
these parameters. If no parameters are specified, we assume we will
detach all related associations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    detach: <span class="keyword">function</span>(ids, options) {
      <span class="keyword">return</span> <span class="keyword">this</span>._handler(<span class="string">'delete'</span>, ids, options);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>Selects any additional columns on the pivot table,
taking a hash of columns which specifies the pivot
column name, and the value the column should take on the
output to the model attributes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    withPivot: <span class="keyword">function</span>(columns) {
      <span class="keyword">if</span> (!_.isArray(columns)) columns = columns ? [columns] : [];
      <span class="keyword">var</span> relatedData = <span class="keyword">this</span>.relatedData;
      relatedData.pivotColumns || (relatedData.pivotColumns = []);
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = columns.length; i &lt; l; i++) {
        <span class="keyword">var</span> column = columns[i];
        <span class="keyword">if</span> (_.isString(column)) {
          relatedData.pivotColumns.push(relatedData.joinTableName + <span class="string">'.'</span> + column + <span class="string">' as _pivot_'</span> + column);
        } <span class="keyword">else</span> {
          <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> column) {
            relatedData.pivotColumns.push(relatedData.joinTableName + <span class="string">'.'</span> + key + <span class="string">' as '</span> + column[key]);
          }
        }
      }
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>Helper for handling either the <code>attach</code> or <code>detach</code> call on
the <code>belongsToMany</code> relationship.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _handler: <span class="keyword">function</span>(method, ids, options) {
      <span class="keyword">var</span> pending = [];
      <span class="keyword">if</span> (ids == <span class="keyword">void</span> <span class="number">0</span>) {
        <span class="keyword">if</span> (method === <span class="string">'insert'</span>) <span class="keyword">return</span> when.resolve(<span class="keyword">this</span>);
        <span class="keyword">if</span> (method === <span class="string">'delete'</span>) pending.push(<span class="keyword">this</span>._processPivot(method, <span class="literal">null</span>, options));
      }
      <span class="keyword">if</span> (!_.isArray(ids)) ids = ids ? [ids] : [];
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = ids.length; i &lt; l; i++) {
        pending.push(<span class="keyword">this</span>._processPivot(method, ids[i], options));
      }
      <span class="keyword">var</span> collection = <span class="keyword">this</span>;
      <span class="keyword">return</span> when.all(pending).then(<span class="keyword">function</span>() {
        <span class="keyword">return</span> collection;
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>Handles setting the appropriate constraints and shelling out
to either the <code>insert</code> or <code>delete</code> call for the current model,
returning a promise.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _processPivot: <span class="keyword">function</span>(method, item, options) {
      <span class="keyword">var</span> data = {};
      <span class="keyword">var</span> relatedData = <span class="keyword">this</span>.relatedData;
      data[relatedData.otherKey] = relatedData.fkValue;</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>If the item is an object, it&#39;s either a model
that we&#39;re looking to attach to this model, or
a hash of attributes to set in the relation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> (_.isObject(item)) {
        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> Model) {
          data[relatedData.foreignKey] = item.id;
        } <span class="keyword">else</span> {
          _.extend(data, item);
        }
      } <span class="keyword">else</span> <span class="keyword">if</span> (item) {
        data[relatedData.foreignKey] = item;
      }
      <span class="keyword">var</span> builder = <span class="keyword">this</span>.builder(relatedData.joinTableName);
      <span class="keyword">if</span> (options &amp;&amp; options.transacting) {
        builder.transacting(options.transacting);
      }
      <span class="keyword">if</span> (method === <span class="string">'delete'</span>) <span class="keyword">return</span> builder.where(data).del();
      <span class="keyword">return</span> builder.insert(data);
    }

  };</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>Creates a new object, extending an object that
does not inherit the <code>Object.prototype</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> extendNull = <span class="keyword">function</span>(target) {
    <span class="keyword">return</span> _.extend(Object.create(<span class="literal">null</span>), target);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>Finds the specific <code>morphTo</code> table we should be working with, or throws
an error if none is matched.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> morphCandidate = <span class="keyword">function</span>(candidates, foreignTable) {
    <span class="keyword">var</span> Target = _.find(candidates, <span class="keyword">function</span>(Candidate) {
      <span class="keyword">return</span> (_.result(Candidate.prototype, <span class="string">'tableName'</span>) === foreignTable);
    });
    <span class="keyword">if</span> (!Target) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'The target polymorphic model was not found'</span>);
    }
    <span class="keyword">return</span> Target;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>Simple memoization of the singularize call.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> singularMemo = (<span class="keyword">function</span>() {
    <span class="keyword">var</span> cache = Object.create(<span class="literal">null</span>);
    <span class="keyword">return</span> <span class="keyword">function</span>(arg) {
      <span class="keyword">if</span> (arg <span class="keyword">in</span> cache) {
        <span class="keyword">return</span> cache[arg];
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> cache[arg] = Inflection.singularize(arg);
      }
    };
  }());</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>References to the default <code>Knex</code> and <code>Knex.Transaction</code>, overwritten
when a new database connection is created in <code>Initialize</code> below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Bookshelf.Knex = Knex;
  Bookshelf.Transaction = Knex.Transaction;</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <h2>Bookshelf.Initialize</h2>

            </div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>Configure the <code>Bookshelf</code> settings (database adapter, etc.) once,
so it is ready on first model initialization.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Bookshelf.Initialize = <span class="keyword">function</span>(name, options) {
    <span class="keyword">var</span> Target;
    <span class="keyword">if</span> (_.isObject(name)) {
      options = name;
      name = <span class="string">'main'</span>;
    }
    <span class="keyword">if</span> (Bookshelf.Instances[name]) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'A '</span> + name + <span class="string">' instance of Bookshelf already exists'</span>);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>If an object with this name already exists in <code>Knex.Instances</code>, we will
use that copy of <code>Knex</code> without trying to re-initialize.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> Builder = (Knex[name] || Knex.Initialize(name, options));

    <span class="keyword">if</span> (name === <span class="string">'main'</span>) {
      Target = Bookshelf.Instances[<span class="string">'main'</span>] = Bookshelf;
    } <span class="keyword">else</span> {
      Target = Bookshelf.Instances[name] = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>Create a new <code>Bookshelf</code> instance for this database connection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      _.extend(Target, _.omit(Bookshelf, <span class="string">'Instances'</span>, <span class="string">'Initialize'</span>, <span class="string">'Knex'</span>, <span class="string">'Transaction'</span>, <span class="string">'VERSION'</span>), {
        Knex: Builder,
        Transaction: Builder.Transaction
      });</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>Attach a new builder function that references the correct connection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      _.each([<span class="string">'Model'</span>, <span class="string">'Collection'</span>, <span class="string">'EagerRelation'</span>], <span class="keyword">function</span>(item) {
        Target[item] = Bookshelf[item].extend({
          builder: <span class="keyword">function</span>(table) {
            <span class="keyword">return</span> Builder(table);
          }
        });
      });
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>Set the instanceName, so we know what Bookshelf we&#39;re using.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Target.instanceName = name;</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>Return the initialized instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">return</span> Target;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>Named instances of Bookshelf, presumably with different <code>Knex</code>
options, to initialize different databases.
The main instance being named &quot;main&quot;...</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Bookshelf.Instances = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>The main Bookshelf <code>instanceName</code>... incase we&#39;re using Bookshelf
after <code>Knex</code> has been initialized, for consistency.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Bookshelf.instanceName = <span class="string">'main'</span>;

  module.exports = Bookshelf;

}).call(<span class="keyword">this</span>);</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
